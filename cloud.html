<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <!-- Bootstrap CSS -->
    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet">


    <title>APIs and Cloud Computing</title>
</head>
<body>
<div class="container">
    <div class="row ">
        <h1><a href="index.html">Home</a></h1>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h1>Cloud Computing</h1>
        <p>
            As part of a graduate course in cloud computing, I worked with a group to develop a container testing service.
            Many organizations host their web applications using containers (see below) that run on cloud infrastructure.
            Our group determined that a service allowing organizations to test their containerized applications in a
            simulated cloud based production environment would be met with enthusiasm. The service we would implement
            would allow for for our clients to upload a container image to our infrastructure. Our service would then provision
            the necessary resources to deploy and test this container. Almost immediately, we recognized that
            providing such a service entailed exposing our infrastructure to abuse by malicious actors. For example
            it would be trivial to upload a container intended to misuse our cloud infrastructure for the purpose of
            mining monero or some other cryptocurrency, or to provision web hosting services in order to facilitate illegal
            activity. We determined it would be necessary to thoroughly vet our clients and also to require them to
            register an account with us before using our service. My contribution to this project was to create an
            authentication <a href="https://en.wikipedia.org/wiki/Microservices">microservice</a> that would be used to
            authenticate our clients before they could access our service.
        </p>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h1>What is an API? What are containers?</h1>
        <p>
            Generally speaking, an API is a software intermediary that allows two applications to talk to each other.
            For example, if you are using your phone and want to access a YouTube video your phone will communicate with
            the YouTube servers using an intermediary API that takes your phone’s request, retrieves the data from
            YouTube’s servers, and returns it to your device.
            An API also adds a layer of security by ensuring that the two devices only access each other through a
            predefined intermediary. However, APIs can actually be security flaws if the access to the API is not
            properly controlled and have been for websites such as Facebook.
            Modern APIs often rely on standards (such as HTTP or REST) which are friendly to developers and widely
            understood.
        </p>
        <p>
            The functional unit of an API is known as an <i>endpoint</i>. Endpoints can be implemented to perform specific
            functions. Imagine an API that is contacted in order to retrieve up-to-date weather information.
            One endpoint may return jSON data describing a weather forecast and another endpoint may return current weather
            information. Most APIs are contacted via the public internet, and in such cases the API is accessed
            at it's <i>base url</i>. For example, the United States National Weather Service provides a free and
            public API providing weather information at the base address <a href="https://api.weather.gov">https://api.weather.gov</a>.
            Navigating to this link in a web browser or requesting the page via cURL or similar command line tool will
            return a message informing the API consumer of the APIs status. Specific endpoints can be accessed by
            appending to the <i>base url</i>. For example, <a href="https://api.weather.gov/alerts">https://api.weather.gov/alerts</a>
             returns a list of all current weather alerts in the United States.
        </p>
        <p>
            Frequently, APIs
            are run in <a href="https://www.docker.com/resources/what-container/">Docker containers</a> which allows them to
            be highly portable (able to operate on a wide variety of infrastructure across various operating systems) and
            also highly efficient (operate on as little computing resources as possible). A developer is able to write
            a recipe describing a particular container using a <a href="https://docs.docker.com/engine/reference/builder/">dockerfile</a>.
            The example below demonstrates the specification necessary to run an API accessing Amazon Web Services (AWS)
            resources. This dockerfile will be used to house the API examined in depth on this page:
        </p>
        <div class="col-md-6">
            <pre>
                <code>
FROM python:3.8-slim-buster
WORKDIR /app
ENV AWS_DEFAULT_REGION=us-west-2
ENV AWS_ACCESS_KEY_ID="REDACTED"
ENV AWS_SECRET_ACCESS_KEY="REDACTED"
COPY ./requirements.txt /app/requirements.txt
COPY ./main.py /app/main.py
RUN pip3 install --no-cache-dir --upgrade -r /app/requirements.txt
EXPOSE 5555
CMD [ "uvicorn", "main:app", "--proxy-headers", "--host", "0.0.0.0", "--port", "5555" ]
                </code>
            </pre>
        </div>
        <div class="col-md-6">
            <ul>
                <li>
                    The <code>FROM</code> instruction specifies a parent image to install onto the container, in
                    this case a variant of Debian Buster that contains the minimal dependencies (slim) required to run
                    Python 3.8.
                </li>
                <li>
                    The <code>WORKDIR</code> instruction sets thr working directory for any subsequent <code>RUN</code>
                    commands
                </li>
                <li>
                    Environment variables can be specified using the <code>ENV</code> instruction. In this case, such
                    environment variables are credentials to access AWS resources and have thus been redacted
                </li>
                <li>
                    The <code>COPY</code> instruction has been used here to copy files from the local machine into the
                    container
                </li>
                <li>
                    The <code>RUN</code> instruction is used to execute a command that will install packages required
                    by the API
                </li>
                <li>
                    The <code>EXPOSE</code> instruction is used to instruct the container to listen on a specific port
                    at runtime
                </li>
                <li>
                    The <code>CMD</code> instruction specifies a command to execute once runtime begins
                </li>
            </ul>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h1>Developing a backend authentication API</h1>
        <p>
            I have used <a href="https://fastapi.tiangolo.com/">FastAPI</a> to implement the back-end logic required
            for performing authentication. I've chosen FastAPI over competing API frameworks because I was very impressed
            with the documentation provided by FastAPI. Not only where the getting started tutorials on their website
            excellent, but within the API itself once can navigate to a built in <code>/docs</code> endpoint and
            interact with the various endpoints contained within the API (This will be demonstrated below). Let's take a
            look at our API implementation, it is very straightforward:
        </p>
    </div>
    <div class="row">
        <div class="col-md-6">
      <pre>
        <code>
import hashlib
import hmac
import os
from typing import Tuple
import boto3
import uvicorn
from fastapi import FastAPI, Form

app = FastAPI()
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('clients')
        </code>
    </pre>
    </div>
        <div class="col-md-6">
            <ul>
                <li>
                    After adding the necessary import statements, we initialize our FastAPI instance to a variable
                    <code>app</code> and also initialize variables used to access an AWS DynamoDB table that will be
                    used to store client credentials
                </li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            <pre>
                <code>
def hash_new_password(password: str) -> Tuple[bytes, bytes]:
    """
    Hash the provided password with a randomly-generated salt,
    encode as base64, and return the salt and hash for storage.
    """
    salt = os.urandom(64)
    hashed_password = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)
    return salt, hashed_password


def is_correct_password(salt: bytes, hashed_password: bytes, password: str) -> bool:
    """
    Given a previously-stored salt/hash and a password in a current
    authentication attempt check whether the password is correct.
    """
    return hmac.compare_digest(
        hashed_password,
        hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)
    )
                </code>
            </pre>
    </div>
        <div class="col-md-6">
            <ul>
                <li>
                    Next, two helper functions are defined that will be used for authentication
                </li>
                <li>
                    <code>hash_new_password()</code> accepts as an argument a string corresponding to a password
                    provided by the client during the registration process.
                </li>
                <li>
                    The password is
                    <a href="https://en.wikipedia.org/wiki/Rainbow_table#Defense_against_rainbow_tables">salted</a>
                    to increase entropy during hashing and mitigate
                    <a href="https://en.wikipedia.org/wiki/Rainbow_table">rainbow table</a> attacks.
                </li>
                <li>
                    After salting, the password is hashed successively, in this case 10,000 times, and the resulting
                    hash as well as the salt used are returned by the function. <br><br><br><br>
                </li>
                <li>
                    <code>is_correct_password()</code> accepts three arguemnts:
                    <ol>
                        <li>
                            A salt that was used to hash a client provided password
                        </li>
                        <li>
                            A hash of the same client provided password
                        </li>
                        <li>
                            A new password (unhashed) that is being provided in an authentication attempt
                        </li>
                    </ol>
                </li>
                <li>
                    This function will repeat the hashing process defined in <code>hash_new_password()</code>
                    using the previously stored salt, and if the resulting hash matches the stored hash, the password
                    can be considered correct.
                </li>
            </ul>
        </div>
    </div>
    <h5>The remainder of the API implementation involves defining endpoints and how they should behave:</h5>
    <div class="row">
        <div class="col-md-6">
            <pre>
                <code>
@app.post("/register/")
async def register(username: str = Form(...), password: str = Form(...)):
    """
    Accepts an email address and password as parameters, calls hash_new_password in order
    to hash and salt the password and then stores the email, salt, and hashed password in a
    DynamoDB table.
    :param username:
    :param password:
    :return:
    """
    salt, hashed_password = hash_new_password(password)
    table.put_item(
        Item= {
            'email': username,
            'salt': salt,
            'password': hashed_password
        }
    )
    return {f"Success! {username} has been registered."}


@app.post("/authenticate/")
async def authenticate(username: str = Form(...), password: str = Form(...)):
    """
    Accepts a previously registered email and password combination, if valid this function
    will return redirect to API root after setting a session cookie.
    :param username:
    :param password:
    :return:
    """
    try:
        response = table.get_item(Key={'email': username})
        item = response['Item']
        stored_salt = item['salt'].value
        stored_password = item['password'].value
        return is_correct_password(stored_salt, stored_password, password)
    except KeyError:
        return "The email you entered has not been registered."


@app.post("/authenticate_no_form/")
async def authenticate_no_form(username: str, password: str):
    """
    Accepts a previously registered email and password combination, if valid this function
    will return redirect to API root after setting a session cookie.
    :param username:
    :param password:
    :return:
    """
    try:
        response = table.get_item(Key={'email': username})
        item = response['Item']
        stored_salt = item['salt'].value
        stored_password = item['password'].value
        return is_correct_password(stored_salt, stored_password, password)
    except KeyError:
        return "The email you entered has not been registered."

if __name__ == '__main__':
    uvicorn.run("main:app", host='localhost', port=5555, reload=True)
                </code>
            </pre>
        </div>
        <div class="col-md-6">
            <ul>
                <li>
                    In FastAPI endpoints are defined using the annotation pattern
                    <code>@&lt;app_name&gt;.&lt;HTTP_request_type&gt;(/"&lt;path_to_endpoint&gt;")</code>
                </li>
                <li>
                    This means API consumers can access the endpoint by navigating to the base url followed by the
                    endpoints path, i.e. <code>authenticator_api.dev/register/</code>
                </li>
                <li>
                    The <code>register</code> endpoint uses the helper function <code>hash_new_password()</code>
                    in irder to obtain a salt and hashed password provided during a registration attempt. These values
                    will be stored as a DynamoDB table row where the client email serves as a primary key
                </li>
            </ul>
        </div>
    </div>

</div>


<!-- Option 1: Bootstrap Bundle with Popper -->
<script crossorigin="anonymous"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>