<!doctype html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <!-- Bootstrap CSS -->
    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet">

    <link href="style.css" rel="stylesheet"/>

    <title>Mobile Application Development</title>
</head>
<body>
<div class="container">
    <div class="row ">
        <h1><a href="index.html">Home</a></h1>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>Mobile Application Development</h3>
            <p>Eager to learn more about software development, and disappointed by the course offerings at UMT,
                I was fortunate to work with Patricia Duce in order to complete an Android Developer
                <a href="https://developer.android.com/courses/android-basics-kotlin/course">training course</a>
                and use the material contained therein to develop a course taught for the first time at UMT in Fall,
                2022.
            </p>
            <br>
            <h3>What I've Learned: Application Fundamentals</h3>
            <p>
                Android development has been an excellent way to get hands on practice writing clean code and
                to work with software architecture patterns commonly found in industry applications,
                especially <i>model-view-viewmodel (
                <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVMM</a></i>) which is
                <a href="https://developer.android.com/jetpack/guide">endorsed</a> as a best practice
                when building Android apps.
            </p>
            <p> According to Android:</p>
            <blockquote CITE="https://developer.android.com/jetpack/guide"><I>
                Another important principle is that you should drive your UI from data models, preferably persistent
                models.
                Data models represent the data of an app. They're independent of the UI elements and other components
                in your app. This means that they are not tied to the UI and app component lifecycle, but will still be
                destroyed when the OS decides to remove the app's process from memory.
            </I></blockquote>
            <p>
                This effectively separates the application into two layers: a user-interface (UI) layer, and
                a data layer. This concept is just one example of various design principles that I learned while
                exploring mobile application development.
            </p>
            <p>
                While Android applications have historically been written in Java Google announced in May 2019
                that the officially supported language for Android development would be
                <a href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)">Kotlin</a>.
                Kotlin has much in common with Java but its syntax has been changed to support type inference and
                eliminate the terminating semicolons, among many other features such as inline lambda functions,
                null safety, range expressions, and coroutines, all of which were explored in depth in the
                <a href="https://developer.android.com/courses/android-basics-kotlin/course">training course</a>.
            </p>
            <p>
                This course also emphasised the importance of testing application code, and each module contained an
                activity related to writing effective unit and functional tests.
                After teaching foundational concepts such as user interface (UI) management using layout resource files,
                click listeners, etc. the course demonstrated how to implement a
                <a href="https://developer.android.com/guide/topics/ui/layout/recyclerview">Recycler View</a>.
                Recycler Views are the component inside of Android applications that allow for an infinitely scrollable
                list.
                Think of any 'feed' you have encountered such as news feed on LinkedIn or Twitter, and you have the
                idea..
                Recycler Views have been designed to provide a user-friendly
                experience by scrolling smoothly and not freezing or jerking as fresh list items are loaded into the
                list.
            </p>
            <p>
                THe following is a code snippet from my application <i>ListMaker</i> which demonstrates the use of a
                Recycler View. Its individual components will be explained below:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
class MainAdapter(
    private val onItemClick: (MainItem) -> Unit, private val onItemLongClick: (MainItem) -> Boolean
) : ListAdapter<MainItem, MainAdapter.ViewHolder>(DiffCallback) {

    companion object DiffCallback : DiffUtil.ItemCallback<MainItem>() {
        override fun areItemsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem.itemName == newItem.itemName
        }

        override fun areContentsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem == newItem
        }

    }

    class ViewHolder(private var binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bind(item: MainItem) {
            binding.listItemText.text = item.itemName.toString()
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val viewHolder = ViewHolder(
            ListItemBinding.inflate(
                LayoutInflater.from(parent.context),
                parent,
                false
            )
        )
        viewHolder.itemView.setOnClickListener {
            val position = viewHolder.adapterPosition
            onItemClick(getItem(position))
        }
        viewHolder.itemView.setOnLongClickListener {
            val position = viewHolder.adapterPosition
            onItemLongClick(getItem(position))
        }
        return viewHolder
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <div class="pt-3"></div>
            <ul>
                <li>
                    The <i>MainAdapter</i> class constructor expects as arguments two click listeners that determine
                    what occurs if a list item is clicked or long-clicked respectively and extends the
                    <i>ListAdapter</i>
                    class which expects a <i>DifCallback</i> object as an argument.
                </li>
                <li>
                    <i>ListAdapter</i> is a base class used for presenting list data in a Recycler View.
                </li>
                <li>
                    <i>DiffCallback</i> is a class that contains methods for computing the difference between two lists
                    and is useful to detect when only one or a few list elements have changed, and update only those
                    elements as opposed to the entire list. Here <i>DiffCallback</i> is implemented as a
                    <a href="https://kotlinlang.org/docs/object-declarations.html#companion-objects">companion
                        object</a>.
                </li>
                <li>
                    A companion object is an example of the <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton
                    design pattern</a>
                    and also resemble static objects in Java in the sense that they belong to a specific class but not
                    a given instance of that class.
                </li>
                <li>
                    The <code>ViewHolder</code> class accepts a <code>ListItemBinding</code> object as an argument. A
                    <code>ListItem</code> has been defined
                    in a separate xml file and in this case contains only instructions on how to display a text field.
                    The <code>ViewHolder</code> class is responsible for using this binding object to set
                    the text field of a given
                    list item to the appropriate item's name in the <code>bind</code> function.
                </li>
                <li>
                    The <code>onCreateViewHolder</code> function returns a <code>ViewHolder</code> and is responsible
                    for
                    <a href="https://developer.android.com/reference/android/view/LayoutInflater">inflating</a> the
                    <code>ListItem</code> view.
                </li>
                <li>
                    Additionally two click listeners are set within <code>onCreateViewHolder</code>. Additionally
                    listeners can be set here as well that handle the application's response to specific gestures
                    or other events.
                </li>
                <li>
                    Lastly, the <code>onBindViewHolder</code> function is responsible for performing the work defined
                    in <code>onCreateViewHolder</code> and therefore also any work defined in the <code>bind</code>
                    function in the <code>ViewHolder</code> constructor. In this case this entails setting a
                    <code>ListItem</code>'s text field to the appropriate item's name and setting two click listeners.
                </li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: Application Navigation</h3>
            <p>
                Android provides a
                <a href="https://developer.android.com/guide/navigation/navigation-getting-started">Navigation
                    Component</a>
                which is intended to simply the process of navigating between views within an application. In Android,
                any screen displayed to a user is a view that has been defined in a <code>layout.xml</code> file. These
                views can
                be either activities or fragments. Simple applications can usually be contained within a single activity
                and make use of fragments to display different views. Utilizing the Navigation Component in such a
                situation is described below. The code for these examples has been taken from my solution to a
                <a href="https://developer.android.com/codelabs/basic-android-kotlin-training-project-lunch-tray#0">project</a>
                in the third module of the <a href="https://developer.android.com/courses/android-basics-kotlin/course">Android
                Basics in Kotlin</a>
                course:
            </p>
            <ol>
                <li>
                    Android applications have their programmatic entry point located in a <code>MainActivity</code>
                    class (this can be modified in the <code>AndroidManifest.xml</code> file, but changing this doesn't
                    appear to be a common practice). Within <code>MainActivity</code> we can initialize a
                    <code>NavHostFragment</code> which is a fragment that will be used to display the views contained
                    within our app. This fragment is owned by the <code>NavHost</code>, which contains the conext
                    for naviagting using a <code>NavController</code>. We also initialize this
                    <code>NavController</code>
                    within <code>MainActivity</code>. These steps are demonstrated in the code below:
                    <pre>
                        <code>
class MainActivity : AppCompatActivity() {

    private lateinit var navController: NavController

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_main)

        val navHostFragment = supportFragmentManager
            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment

        navController = navHostFragment.navController

        setupActionBarWithNavController(navController)
    }
}
                        </code>
                    </pre>
                </li>
                <li>
                    Next, a <code>navGraph.xml</code> is necessary in order to define the fragments known to the
                    <code>NavHost</code> and define both the directionality between fragments and their
                    corresponding layout files:
                    <pre>
                        <code>
                        <textarea cols="85" rows="10">
<fragment
        android:id="@+id/startOrderFragment"
        android:name="com.example.lunchtray.ui.order.StartOrderFragment"
        android:label="fragment_start_order"
        tools:layout="@layout/fragment_start_order" >
        <action
            android:id="@+id/action_startOrderFragment_to_entreeMenuFragment"
            app:destination="@id/entreeMenuFragment" />
    </fragment>
    <fragment
        android:id="@+id/entreeMenuFragment"
        android:name="com.example.lunchtray.ui.order.EntreeMenuFragment"
        android:label="fragment_entree_menu"
        tools:layout="@layout/fragment_entree_menu" >
        <action
            android:id="@+id/action_entreeMenuFragment_to_sideMenuFragment"
            app:destination="@id/sideMenuFragment" />
        <action
            android:id="@+id/action_entreeMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/sideMenuFragment"
        android:name="com.example.lunchtray.ui.order.SideMenuFragment"
        android:label="fragment_side_menu"
        tools:layout="@layout/fragment_side_menu" >
        <action
            android:id="@+id/action_sideMenuFragment_to_accompanimentMenuFragment"
            app:destination="@id/accompanimentMenuFragment" />
        <action
            android:id="@+id/action_sideMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/accompanimentMenuFragment"
        android:name="com.example.lunchtray.ui.order.AccompanimentMenuFragment"
        android:label="fragment_accompaniment_menu"
        tools:layout="@layout/fragment_accompaniment_menu" >
        <action
            android:id="@+id/action_accompanimentMenuFragment_to_checkoutFragment"
            app:destination="@id/checkoutFragment" />
        <action
            android:id="@+id/action_accompanimentMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/checkoutFragment"
        android:name="com.example.lunchtray.ui.order.CheckoutFragment"
        android:label="fragment_checkout"
        tools:layout="@layout/fragment_checkout" >
        <action
            android:id="@+id/action_checkoutFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
                        </textarea>
                        </code>
                    </pre>
                </li>
                <li>
                    Now click listeners must be incorporated into each fragment that will trigger the appropriate
                    transition from one view to another:
                    <pre>
                        <Code>
class StartOrderFragment : Fragment() {
    private var _binding: FragmentStartOrderBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        _binding = FragmentStartOrderBinding.inflate(inflater, container, false)
        val root: View = binding.root
        // Navigate to entree menu
        binding.startOrderBtn.setOnClickListener { // Setting the click listener to call navigation action
            findNavController().navigate(R.id.action_startOrderFragment_to_entreeMenuFragment)
        }
        return root
    }
}
                        </Code>
                    </pre>
                </li>
            </ol>
            <p>
                These steps demonstrate the implementation of code directly related to the Navigation Component, but it
                is
                worth noting that additional steps are necessary such as placing a <code>FragmentContainerView</code>
                inside the <code>MainActivity</code> layout file as well as defining the layout files for each
                individual fragment. (This app also makes use of a <code>ViewModel</code>, but this will be discussed
                in another section). Once all this has been finished, we can navigate through the application as
                demonstrated below:
            </p>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-4 ">
            <img src="images/LunchTray/start_order.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/entree.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/side.png" width="400">
        </div>
    </div>
    <div class="row">

        <div class="col-md-4 ">
            <img src="images/LunchTray/accomp.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/checkout.png" width="400">
        </div>
        <div class="col-md-4 text-center my-auto">
            <p>
                Clicking the back arrow located in the AppBar at the top of the screen will result in a navigation
                action that displays the previosuly shown fragment.
            </p>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: ViewModels and MVVM Architecture</h3>
            <p>
                In Android a
                <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a>
                is used to store application data in a way that respects the Android application
                <a href="https://developer.android.com/guide/components/activities/activity-lifecycle">lifecycle</a>.
                If data were to be stored local to a given activity or fragment, this data could be lost for any number
                of reasons out of the control of the application user or programmer such as rotating the device screen,
                the operating system re-allocating memory resources, and the activity or fragment loosing focus.
                Additionally, ViewModels simplify the process of sharing data between fragments. Separating application
                data from the user-interface is a common pattern in commercial codebases.
            </p>
            <p>
                To explore the implementation of a ViewModel I have copied code from my solution to the
                <a href="https://developer.android.com/codelabs/basic-android-kotlin-training-shared-viewmodel#0">Cupcake</a>
                codelab.
                Implementing a ViewModel within an application begins by simply declaring a new class that
                extends the ViewModel base class:
            <pre>
            <code>
class OrderViewModel : ViewModel() { }
            </code>
        </pre>
            <p>
                Next we define fields for our <code>OrderViewModel</code> class. There is a convention when doing this
                in Kotlin termed the <i>backing property</i> which holds that a mutable private variable is accessed
                by any functions within the <code>OrderViewModel</code> class and an immutable public variable is then
                provided for other classes
                to access. This is similar in theory to using getters and setters in Java. The example below uses
                <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a>
                types:
            <pre>
            <code>
     private val _quantity = MutableLiveData<Int>()
    val quantity: LiveData<Int> = _quantity

    private val _flavor = MutableLiveData<String>()
    val flavor: LiveData<String> = _flavor

    private val _date = MutableLiveData<String>()
    val date: LiveData<String> = _date

    private val _price = MutableLiveData<Double>()
    val price: LiveData<String> = Transformations.map(_price) {
        NumberFormat.getCurrencyInstance().format(it)
    }
            </code>
        </pre>
            <p>
                The following function definitions demonstrate how the private immutable variables are used within
                the <code>OrderViewModel</code> class:
            <pre>
            <code>
    fun setQuantity(numberCupcakes: Int) {
        _quantity.value = numberCupcakes
        updatePrice()
    }

    fun setFlavor(desiredFlavor: String) {
        _flavor.value = desiredFlavor
    }

    fun setDate(pickupDate: String) {
        _date.value = pickupDate
        updatePrice()
    }

    fun hasNoFalvorSet(): Boolean {
        return _flavor.value.isNullOrEmpty()
    }

    private fun updatePrice() {
        var calculatedPrice = (quantity.value ?: 0) * PRICE_PER_CUPCAKE
        if (dateOptions[0] == _date.value) {
            calculatedPrice += PRICE_FOR_SAME_DAY_PICKUP
        }
        _price.value = calculatedPrice
    }
            </code>
        </pre>
            <p>
                Now that our <code>OrderViewModel</code> is implemented, we can access its fields and methods from
                within our application. The following example demonstrates accessing <code>OrderViewModel</code>
                from the fragment <code>StartFragment</code>:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">

            <pre>
            <code>
class StartFragment : Fragment() {

    private val sharedViewModel: OrderViewModel by activityViewModels()

    ...

    // Begin a cupcake order by setting number of cupcakes and their flavor
    fun orderCupcake(quantity: Int) {
        sharedViewModel.setQuantity(quantity)
        if (sharedViewModel.hasNoFalvorSet()) {
            sharedViewModel.setFlavor(getString(R.string.vanilla))
        }
        findNavController().navigate(R.id.action_startFragment_to_flavorFragment)
    }
}
            </code>
        </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    <code>activityViewModels()</code> is called to return access to an <code>OrderViewModel</code>
                    instance shared between all fragments in the activity. The reference to this instance
                    is declared in a variable <code>sharedViewModel</code>
                </li>
                <li>
                    The methods defined in <code>OrderViewModel</code> can be accessed in order to update the value
                    of the fields such as quantity and flavor.
                </li>
            </ul>
        </div>
    </div>
    <p>
        Implementing a <code>ViewModel</code> is very straightforward and provides an easy way for fragments to
        access data that they have a common interest in. It also avoids numerous problems that can occur when code
        corresponding to the user interface stores application data.
    </p>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: Retrieving Data from the Internet</h3>
            <p>
                Most mobile applications perform network requests in order to retrieve and display information to
                their users such as emails, videos, and in the example for this section weather alerts. Android
                recommends
                reforming this work on a background thread since network requests can take a significant amount of time
                to complete. Performing network requests on the <i>main thread</i>, also known as the <i>UI thread</i>
                in
                Android because this is where UI information processed, is not recommended. It is best practice to
                perform these
                requests on a background thread in order to avoid the application appearing to freeze while the network
                request
                is handled. This situation is the basis of
                <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)">asynchronus programming</a>.
                Additionally, Android recommends segregating application code relating to netowrk requests within its
                own package, a practice which adheres to the
                <a href="https://en.wikipedia.org/wiki/Modular_programming">modular design</a> technique. In the example
                below,
                we will explore how this can be accomplished using two open source libraries designed for performing API
                requests and converting the returned JSON into a data class which can be passed in turn to a
                <code>ViewModel</code>.
            </p>
            <p>
                First, we implement our network layer as shown below:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
private const val BASE_URL =
    "https://api.weather.gov/"

private val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory())
    .build()

private val retrofit = Retrofit.Builder()
    .addConverterFactory(MoshiConverterFactory.create(moshi))
    .baseUrl(BASE_URL)
    .build()

interface nwsAlerts {
    @GET("/alerts/active/zone/MTC063")
    suspend fun getALerts(): Alert
}

object Alerts {
    val retrofitService : nwsAlerts by lazy {
        retrofit.create(nwsAlerts::class.java)
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    First, we declare a reference to a <code>BASE_URL</code> which will simplify our API calls.
                </li>
                <li>
                    Next we create a
                    <a href="https://github.com/square/moshi">Moshi</a> object which will be used to deserialize the
                    JSON we receive from the API endpoint into Kotlin data classes (we must still declare these classes,
                    this will be demonstrated in the next section)
                </li>
                <li>
                    Next we must also define a
                    <a href="https://square.github.io/retrofit/">RetroFit</a> object responsible for converting the
                    API HTTP response into an interface
                </li>
                <li>
                    With our RetroFit object declared, we can now implement the interface which describes our API call.
                    In this case we perform an HTTP request to a particular endpoint that will return weather alerts for
                    Missoula County, Montana. The interface describes what the API call will do: return an Alert object,
                    and the next step maps this HTTP request to a function
                    <code>getAlerts()</code> that can be called from within our application code, specifically our
                    <code>ViewModel</code>.
                </li>
                <li>
                    Lastly, we create an <code>Alerts</code> object which holds an immutable variable (val in Kotlin)
                    <code>retrofitService</code> described by the interface above that will be lazily constructed
                    (here lazy means that this process will not occur until the <code>Alerts</code> object is first
                    accessed).
                </li>
            </ul>
        </div>
    </div>
    <div class="row">
        <p>
            Now that our network layer has been implemented, let's look at the JSON data our request will return:
        <pre>
        <code>
{
  "@context": [
    "https://geojson.org/geojson-ld/geojson-context.jsonld",
    {
      "@version": "1.1",
      "wx": "https://api.weather.gov/ontology#",
      "@vocab": "https://api.weather.gov/ontology#"
    }
  ],
  "type": "FeatureCollection",
  "features": [
  {
      "id": "https://api.weather.gov/alerts/urn:oid:2.49.0.1.840.0.aca7b95ba759466c3273df883d6e0473659ffa25.003.1",
      "type": "Feature",
      "geometry": null,
      "properties": {
        "@id": "https://api.weather.gov/alerts/urn:oid:2.49.0.1.840.0.aca7b95ba759466c3273df883d6e0473659ffa25.003.1",
        "@type": "wx:Alert",
        "id": "urn:oid:2.49.0.1.840.0.aca7b95ba759466c3273df883d6e0473659ffa25.003.1",
        "areaDesc": "Western Lemhi County; Eastern Lemhi County",
        "geocode": {
          "SAME": [
            "016059"
          ],
          "UGC": [
            "IDZ009",
            "IDZ010"
          ]
        },
        "affectedZones": [
          "https://api.weather.gov/zones/forecast/IDZ009",
          "https://api.weather.gov/zones/forecast/IDZ010"
        ],
        "references": [
          {
            "@id": "https://api.weather.gov/alerts/urn:oid:2.49.0.1.840.0.2e593b9f420cffc3e2c93e8268176059049b9048.002.1",
            "identifier": "urn:oid:2.49.0.1.840.0.2e593b9f420cffc3e2c93e8268176059049b9048.002.1",
            "sender": "w-nws.webmaster@noaa.gov",
            "sent": "2022-04-28T10:32:00-06:00"
          },
          {
            "@id": "https://api.weather.gov/alerts/urn:oid:2.49.0.1.840.0.44104654e0ceaf0ae6560bb03ea5e3be76c3430e.003.1",
            "identifier": "urn:oid:2.49.0.1.840.0.44104654e0ceaf0ae6560bb03ea5e3be76c3430e.003.1",
            "sender": "w-nws.webmaster@noaa.gov",
            "sent": "2022-04-29T02:51:00-06:00"
          }
        ],
        "sent": "2022-04-29T08:45:00-06:00",
        "effective": "2022-04-29T08:45:00-06:00",
        "onset": "2022-04-29T08:45:00-06:00",
        "expires": "2022-04-29T09:45:00-06:00",
        "ends": "2022-04-29T09:00:00-06:00",
        "status": "Actual",
        "messageType": "Update",
        "category": "Met",
        "severity": "Moderate",
        "certainty": "Likely",
        "urgency": "Expected",
        "event": "Winter Weather Advisory",
        "sender": "w-nws.webmaster@noaa.gov",
        "senderName": "NWS Missoula MT",
        "headline": "Winter Weather Advisory issued April 29 at 8:45AM MDT until April 29 at 9:00AM MDT by NWS Missoula MT",
        "description": "Snow showers will continue today, but very minimal impacts are\nexpected, so the advisory will be allowed to expire at 9AM.",
        "instruction": null,
        "response": "Execute",
        "parameters": {
          "AWIPSidentifier": [
            "WSWMSO"
          ],
          "WMOidentifier": [
            "WWUS45 KMSO 291445"
          ],
          "NWSheadline": [
            "WINTER WEATHER ADVISORY WILL EXPIRE AT 9 AM MDT THIS MORNING ABOVE 4500 FEET"
          ],
          "BLOCKCHANNEL": [
            "EAS",
            "NWEM",
            "CMAS"
          ],
          "VTEC": [
            "/O.EXP.KMSO.WW.Y.0029.000000T0000Z-220429T1500Z/"
          ],
          "eventEndingTime": [
            "2022-04-29T15:00:00+00:00"
          ]
        }
      }
    },
        </code>
    </pre>
        <p>
            There is a lot of information here, but we are only concerned with a few onjects in the
            <code>properties</code>
            array. Regardless, we must create data classes that the JSON response can be mapped to:
        <pre>
        <code>
data class Alert (
    @Json(name = "@context") val context: List<Any>,
    val type: String,
    val features: List<AlertFeature>,
    val title: String,
    val updated: String
    )

data class AlertFeature(
    val id: String,
    val type: String,
    val geometry: String?,
    val properties: AlertProperties,
)

data class AlertProperties(
    @Json(name = "@id") val fullId: String,
    @Json(name = "@type") val type: String,
    val id: String,
    val areaDesc: String,
    val geocode: Geocode,
    val affectedZones: List<String>,
    val references: List<com.harr1424.privateweather.network.Reference>,
    val sent: String,
    val effective: String,
    val onset: String,
    val expires: String,
    val ends: String,
    val status: String,
    val messageType: String,
    val category: String,
    val severity: String,
    val certainty: String,
    val urgency: String,
    val event: String,
    val sender: String,
    val senderName: String,
    val headline: String,
    val description: String,
    val instruction: String,
    val response: String,
    val parameters: Parameter
)

data class Geocode(
    val SAME: List<String>,
    val UGC: List<String>
)

data class Reference(
    @Json(name = "@id") val id: String,
    val identifier: String,
    val sender: String,
    val sent: String
)

data class Parameter(
    val AWIPSidentifier: List<String>,
    val WMOidentifier: List<String>,
    val BLOCKCHANNEL: List<String>,
    //@Json(name = "EAS-ORG") val EASORG: List<String>,
    val VTEC: List<String>,
    val eventEndingTime: List<String>,
    //val expiredReferences: List<String>
)
        </code>
    </pre>
        <p>
            Now that we have created classes (for each JSON array) and fields (for each JSON object) we can begin to
            work with the data returned by the API:
        </p>
    </div>
    <div class="row">
        <div class="col-md-6 ">

            <pre>
        <code>
class AlertViewModel : ViewModel() {

    enum class AlertStatus { LOADING, ERROR, DONE }

    private val _status = MutableLiveData<AlertStatus>()
    val status: LiveData<AlertStatus> = _status

    private val _alerts = MutableLiveData<Alert>()
    val alerts: LiveData<Alert> = _alerts

    /**
     * Call getAlerts() on init so we can display status immediately.
     */
    init {
        getAlerts()
    }

    private fun getAlerts() {
        viewModelScope.launch {
            _status.value = AlertStatus.LOADING
            try {
                _alerts.value = Alerts.retrofitService.getALerts()
                _status.value = AlertStatus.DONE
            } catch (e: Exception) {
                Log.e("Alert", e.toString())
                _status.value = AlertStatus.ERROR
                _alerts.value = Alert(context = listOf(),
                type = "ERROR", features = listOf(), title = "ERROR",
                updated = "ERROR")
            }
        }
    }
}
        </code>
    </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    We can declare an <code>enum</code> class that contains the three possible states of our network
                    request: <code>LOADING, ERROR, DONE</code>
                </li>
                <li>
                    We declare fields (using the backing property described in the previous section) to hold the value
                    of both the network request status and the API response
                </li>
                <li>
                    The function <code>getAlerts()</code> launches a <code>coroutine</code> (discussed below) that
                    will avoid making any asynchronous requests on the main UI thread
                </li>
                <li>
                    If the request is successful, we can access the <code>Alert</code> object via our
                    <code>AlertViewModel</code>
                </li>
                <li>
                    If any errors occur, the UI will display an error icon and we can examine application logs
                    in order to troubleshoot
                </li>
            </ul>

        </div>
    </div>
    <div class="row">
        <p>
            We performed our network request on a background thread by launching a
            <a href="https://kotlinlang.org/docs/coroutines-overview.html">coroutine</a> from the
            <a href="https://developer.android.com/kotlin/coroutines">ViewModel Scope</a>. This ensures that
            no matter how long the request takes to complete our UI will not appear to freeze.
        </p>

        <p>
            Next it is necessary to define two binding adapters that describe how the data stored in
            <code>AlertViewModel</code> will be displayed:
        </p>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
@BindingAdapter("nwsAlertStatus")
fun bindAlertStatus(statusImageView: ImageView, status: AlertViewModel.AlertStatus) {
    when (status) {
        AlertViewModel.AlertStatus.LOADING -> {
            statusImageView.visibility = View.VISIBLE
            statusImageView.setImageResource(R.drawable.loading_animation)
        }
        AlertViewModel.AlertStatus.ERROR -> {
            statusImageView.visibility = View.VISIBLE
            statusImageView.setImageResource(R.drawable.ic_connection_error)
        }
        AlertViewModel.AlertStatus.DONE -> {
            statusImageView.visibility = View.GONE
        }
    }
}

@BindingAdapter("alertListData")
fun bindRecyclerView(recyclerView: RecyclerView,
                     data: List<AlertFeature>?) {
    val adapter = recyclerView.adapter as AlertAdapter
    adapter.submitList(data)
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    The first binding adapter allows us to bind an appropriate image resource file
                    (either a loading icon or an error icon) to an <code>ImageView</code> in our
                    <code>alert_fragment.xml</code> layout file shown below:
                    <textarea cols="65" rows="10">
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">

    <data>
        <variable
            name="viewModel"
            type="com.harr1424.privateweather.models.AlertViewModel" />
    </data>

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.harr1424.privateweather.MainActivity">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/alert_list"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:padding="6dp"
            android:clipToPadding="false"
            app:alertListData="@{viewModel.alerts.component3()}"
            app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            tools:listitem="@layout/alert_item" />

        <ImageView
            android:id="@+id/alert_status_image"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            app:layout_constraintBottom_toBottomOf="parent"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintRight_toRightOf="parent"
            app:layout_constraintTop_toTopOf="parent"
            app:nwsAlertStatus="@{viewModel.status}" />


    </androidx.constraintlayout.widget.ConstraintLayout>
</layout>
                    </textarea>
                </li>
                <li>
                    The second binding adapter defines how the <code>Alert</code> data we are interested in will be
                    passed to the <code>RecyclerView</code>. For this, we need to create an <code>AlertAdapter</code>
                    class and also define an <code>alert_item.xml</code> layout file, which will be shown below
                </li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="col-md-8 ">
            <h3><code>AlertAdapter</code></h3>
            <pre>
                <code>
class AlertAdapter :
    androidx.recyclerview.widget.ListAdapter<AlertFeature, AlertAdapter.AlertViewHolder>(DiffCallback){


    class AlertViewHolder(private var binding: AlertItemBinding) :
        RecyclerView.ViewHolder(binding.root) {
        fun bind(alert: AlertFeature) {
            binding.alertHeadline.text = alert.properties.headline
            binding.alertDescription.text = alert.properties.description
            binding.alertInstructions.text = alert.properties.instruction
            binding.executePendingBindings()
        }
    }

    companion object DiffCallback : DiffUtil.ItemCallback<AlertFeature>() {
        override fun areItemsTheSame(oldItem: AlertFeature, newItem: AlertFeature): Boolean {
            return oldItem.id == newItem.id
        }

        override fun areContentsTheSame(oldItem: AlertFeature, newItem: AlertFeature): Boolean {
            return oldItem.properties == newItem.properties
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AlertViewHolder {
        return AlertViewHolder(AlertItemBinding.inflate(LayoutInflater.from(parent.context)))
    }

    override fun onBindViewHolder(holder: AlertViewHolder, position: Int) {
        val alert = getItem(position)
        holder.bind(alert)
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-4">
            <h3><code>alert_item.xml</code></h3>

            <textarea cols="60" rows="30">
<androidx.constraintlayout.widget.ConstraintLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/alert_headline"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="20sp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />
    <TextView
        android:id="@+id/alert_description"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/alert_headline" />

    <TextView
        android:id="@+id/alert_instructions"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="16dp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/alert_description"
        android:layout_marginBottom="32dp"/>
</androidx.constraintlayout.widget.ConstraintLayout>
</layout>
                    </textarea>


        </div>
    </div>
    <div class="row">
        <p>
            With everything implemented, we can run our application and observe the result:
        </p>
        <div class="col-md-4">
        </div>
        <div class="col-md-4">
            <img alt="Alert Fragment Screenshot" class="mx-auto d-block" src="images/Weather/alert.png" width="400"/>
        </div>
        <div class="col-md-4">
        </div>

    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: Persisting user data using the Room library</h3>
            <p>
                Many applications receive and store information from their users. Oftentimes, this is done so that
                a user can return to the application at a later time and retrieve this data. In this section, we will
                explore how the Android Jetpack
                <a href="https://developer.android.com/training/data-storage/room">Room</a> library can be used to
                accomplish this. This section demonstrates how a simple list application or note-taking application
                can be created. This application allows users to create a list of main items where each main item can
                be considered a task category. Clicking on a main item navigates to a list of items grouped as
                children of the main item. For example a main item 'grocery' may be clicked to display a list of
                grocery items such as 'milk', 'eggs', and 'cheese'. This app is my original work and is available on the
                <a href="https://play.google.com/store/apps/details?id=com.harr1424.listmaker&hl=en_US&gl=US">Google
                    Play Store</a>.
            </p>
            <p>
                First we must define a <code>Data Entity</code> which describes a database table using SQL conventions:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
@Entity
data class MainItem(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    @ColumnInfo(name = "item_name") val itemName: String?
)

@Entity(primaryKeys = ["main_item_id", "detail_item_name"])
data class DetailItem(
    @NonNull @ColumnInfo(name = "main_item_id") val mainItemId: Int,
    @NonNull @ColumnInfo(name = "detail_item_name") val detailItemName: String
)
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    The <code>MainItem</code> data class will be used to create a table containing main items
                    and contains only two columns: a unique id identifying the main item and the main item's name
                </li>
                <li>
                    The <code>DetailItem</code> data class will be used to create a table containing detail items
                    and contains two columns: a reference to the parent main item and the detail item name. These
                    columns are combined to form a primary key, in case a detail item appears within multiple
                    main item categories.
                </li>
            </ul>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <p>
            Next, we declare a <code>Data Access Object</code> (DAO) which is just an interface describing what
            operations can be performed on a database table and what this operation will return. The Room library
            provides three DAO operations anytime a DAO is declared: insert, delete, and update. All other table
            operations must be explicitly defined:
        </p>
        <div class="col-md-6 ">
            <pre>
                <code>
@Dao
interface MainItemDao {
    @Query("SELECT * FROM MainItem ORDER BY id ASC")
    fun getAll(): Flow&lt;List&lt;MainItem>>

    @Query("SELECT * FROM MainItem WHERE id = :itemId")
    fun getById(itemId: Int): Flow&lt;MainItem>

    @Query("SELECT * FROM MainItem WHERE item_name LIKE :name")
    fun findByName(name: String): Flow&lt;List&lt;MainItem>>

    @Query(" DELETE FROM detailitem where main_item_id = :mainItemId")
    fun deleteDetailsFromMain(mainItemId: Int)

    @Insert(onConflict = OnConflictStrategy.IGNORE)
    fun insert(item: MainItem)

    @Delete
    fun delete(item: MainItem)

    @Update
    fun update(item: MainItem)
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    The <code>getAll()</code> function corresponds to a SQL query that will return all main items
                    sorted in the order that they were added to the list
                </li>
                <li>
                    The <code>getById()</code> functions corresponds to a SQL query that will return the item matching
                    the id passed to the function as an argument. This will be useful when adding click listeners to
                    each main item in order to define navigation to their detail item list
                </li>
                <li>
                    The <code>findByName()</code> function isn't currently used in this application, but I defined it
                    because I would like to add search functionality in the future.
                </li>
                <li>
                    the <code>deleteDetailsFromMain()</code> function will delete all detail items should their parent
                    main item be deleted by the user
                </li>
                <li>
                    The <code>insert()</code> function has been modified such that if a main item exists already,
                    a duplicate will be ignored
                </li>
                <li>
                    Notice that when function return types are specified above they are wrapped in a
                    <a href="https://developer.android.com/kotlin/flow">Flow</a> type which allows for these values to
                    be
                    continuously updated
                </li>
            </ul>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <p>
            Next we define an <code>AppDatabase</code> class that serves as the application's entry point in
            accessing the persisted data:
        </p>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
@Database(entities = [MainItem::class, DetailItem::class], version = 2)
abstract class AppDatabase : RoomDatabase() {
    abstract fun mainItemDao(): MainItemDao
    abstract fun detailItemDao(): DetailItemDao
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        fun getDatabase(context: Context): AppDatabase{
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "List Item Database"
                )
                    .fallbackToDestructiveMigration()
                    .build()
                INSTANCE = instance
                return instance
            }
        }
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    The <code>AppDatabase</code> class must be annotated with <code>
                    @Database</code> and provide an entities array naming each data entity we have defined above
                </li>
                <li>
                    Optionally a version number may be privided, this is essential is changes have been made to the
                    database architecture, each change necessitates incrementing the version number by one
                </li>
                <li>
                    The <code>AppDatabase</code> class extends the <code>RoomDataBase</code> base class and contains
                    methods corresponding to each DAO that has been implemented
                </li>
                <li>
                    The companion object (along with the <code>BaseApplication</code> class described below
                    ensures that only one instance of the
                    <code>AppDatabase</code> class is available while the application is running
                </li>
            </ul>
        </div>
    </div>
    <div class="row">
        <p>
            We are almost done with our Room specific implementations!
            It is necessary to create a class <code>BaseApplication</code> so as to ensure
            our app accesses our database ac a singleton instance:
        <pre>
        <code>
class BaseApplication : Application() {
    val database: AppDatabase by lazy { AppDatabase.getDatabase(this) }
}
        </code>
    </pre>
        <p>
            And now we must modify our application manifest <code>AndroidManifest.xml</code> so that the application
            launches from the <code>BaseApplication</code> class that we just created:
            <textarea cols="100" rows="20">
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.harr1424.listmaker">
    <application
        android:name = ".BaseApplication"
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.ListMaker">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
            </textarea>
        </p>
        <p>
            Now that we have finished implementing the necessary components to use the Room library in our application,
            we can define our <code>ListViewModel</code> class to contain the logic for accessing the DAOs and
            odifying our database tables:
        <pre>
        <code>
class ListViewModel(
    private val mainItemDao: MainItemDao,
    private val detailItemDao: DetailItemDao
): ViewModel() {
    val allMainItems: LiveData<List<MainItem>> = mainItemDao.getAll().asLiveData()

    fun getDetailItems(mainItemId: Int) : LiveData<List<DetailItem>> {
        return detailItemDao.getDetailFromMain(mainItemId).asLiveData()
    }

    fun addMainItem(mainItem: MainItem) {
        // launch a coroutine and call the DAO method to add a MainItem to the database
        viewModelScope.launch(Dispatchers.IO) {
            mainItemDao.insert(mainItem)
        }
    }

    fun addDetailItem(mainItemId: Int, detailItemName: String) {
        val detailItem = DetailItem(mainItemId = mainItemId, detailItemName = detailItemName)

        // launch a coroutine and call the DAO method to add a DetailItem to the database
        viewModelScope.launch(Dispatchers.IO) {
            detailItemDao.insert(detailItem)
        }
    }

    fun deleteMainItem(mainItem: MainItem) {
        // call the DAO method to delete a MainItem
        viewModelScope.launch(Dispatchers.IO) {
            mainItemDao.delete(mainItem)
        }
    }

    fun deleteDetailItem(detailItem: DetailItem) {
        // call the DAO method to delete a DetailItem
        viewModelScope.launch(Dispatchers.IO) {
            detailItemDao.delete(detailItem)
        }
    }

    fun deleteDetailsFromMain(mainItemId: Int) {
        // call the DAO method to delete all DetailItems belonging to a MainItem
        viewModelScope.launch(Dispatchers.IO) {
            mainItemDao.deleteDetailsFromMain(mainItemId)
        }
    }

    // create a view model factory that takes a MainItemDao and DetailItemDao as properties  and
    // creates a ViewModel
    class ListViewModelFactory(
        private val mainItemDao: MainItemDao,
        private val detailItemDao: DetailItemDao
        ):
        ViewModelProvider.Factory{
        override fun <T : ViewModel> create(modelClass: Class<T>): T {
            if (modelClass.isAssignableFrom(ListViewModel::class.java)) {
                return ListViewModel(mainItemDao, detailItemDao) as T
            }
            throw IllegalArgumentException("Unknown ViewModel class")
        }
    }
        </code>
    </pre>
        <p>
            Since we are displaying a list of <code>MainItem</code> and <code>DetailItem</code> in their respective
            fragments, we must implement adaoter classes for both lists:
        </p>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <h3><code>MainAdapter</code></h3>
            <pre>
                <code>
class MainAdapter(
    private val onItemClick: (MainItem) -> Unit, private val onItemLongClick: (MainItem) -> Boolean
) : ListAdapter<MainItem, MainAdapter.ViewHolder>(DiffCallback) {

    companion object DiffCallback : DiffUtil.ItemCallback<MainItem>() {
        override fun areItemsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem.itemName == newItem.itemName
        }

        override fun areContentsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem == newItem
        }

    }

    class ViewHolder(private var binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bind(item: MainItem) {
            binding.listItemText.text = item.itemName.toString()
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val viewHolder = ViewHolder(
            ListItemBinding.inflate(
                LayoutInflater.from(parent.context),
                parent,
                false
            )
        )
        viewHolder.itemView.setOnClickListener {
            val position = viewHolder.adapterPosition
            onItemClick(getItem(position))
        }
        viewHolder.itemView.setOnLongClickListener {
            val position = viewHolder.adapterPosition
            onItemLongClick(getItem(position))
        }
        return viewHolder
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <h3><code>DetailAdapter</code></h3>
            <pre>
                <code>
class DetailAdapter(
    private val onItemLongClick: (DetailItem) -> Boolean
) : ListAdapter<DetailItem, DetailAdapter.ViewHolder>(DiffCallback) {

    companion object DiffCallback : DiffUtil.ItemCallback<DetailItem>() {
        override fun areItemsTheSame(oldItem: DetailItem, newItem: DetailItem): Boolean {
            return oldItem == newItem
        }

        override fun areContentsTheSame(oldItem: DetailItem, newItem: DetailItem): Boolean {
            return oldItem == newItem
        }
    }

    class ViewHolder(private var binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bind(item: DetailItem) {
            binding.listItemText.text = item.detailItemName
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val viewHolder = ViewHolder(
            ListItemBinding.inflate(
                LayoutInflater.from(parent.context),
                parent,
                false
            )
        )
        viewHolder.itemView.setOnLongClickListener {
            val position = viewHolder.adapterPosition
            onItemLongClick(getItem(position))
        }
        return viewHolder
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}
                </code>
            </pre>
        </div>
        <div class="row">
            <p>
                The last step in our application is to define click listeners, navigation actions, and some additional
                UI components
                (<a href="https://developer.android.com/reference/android/app/AlertDialog">Alert Dialogs</a>
                to confirm the deletion of existing items and receive text necessary to create new items)
                that will work together to perform the expected behavior of our app:
            </p>
        </div>
        <div class="row">
            <div class="col-md-6 ">
                <h3><code>MainListFragment</code></h3>
                <pre>
                    <code>
class MainListFragment : Fragment() {
    private val viewModel: ListViewModel by activityViewModels {
        ListViewModel.ListViewModelFactory(
            (activity?.application as BaseApplication).database.mainItemDao(),
            (activity?.application as BaseApplication).database.detailItemDao(),
        )
    }
    private var _binding: FragmentMainListBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentMainListBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // Add click listener to floating action button
        binding.fabMain.setOnClickListener {
            addListItem()
        }
        val recyclerView = binding.mainListView
        recyclerView.layoutManager = LinearLayoutManager(requireContext())

        // lambda for click behavior
        // navigate to appropriate detail list
        val click = { mainItem: MainItem ->
            val action =
                MainListFragmentDirections.actionMainListFragmentToDetailListFragment(mainItem.id, mainItem.itemName!!)
            findNavController().navigate(action)
        }

        // lambda for long click behavior
        // delete longclicked item
        val longClick = { item: MainItem ->
            deleteListItem(item)
        }

        // MainAdapter takes params onClickListener and onLongClickListener
        val adapter = MainAdapter(click, longClick)
        recyclerView.adapter = adapter
        viewModel.allMainItems.observe(this.viewLifecycleOwner) { items ->
            items.let {
                adapter.submitList(it)
                adapter.notifyDataSetChanged()
            }
        }
    }

    private fun addListItem() {
        val input = EditText(activity)
        input.hint = "Item name"
        input.inputType = InputType.TYPE_CLASS_TEXT
        activity?.let {
            val builder = AlertDialog.Builder(activity)
            builder.apply {
                setTitle("Add List Item")
                setView(input)
                setPositiveButton(
                    "Add"
                ) { _, _ ->
                    val newItem = MainItem(itemName = input.text.toString())
                    viewModel.addMainItem(newItem)
                }
                setNegativeButton(
                    "Cancel"
                ) { dialog, _ ->
                    dialog.cancel()
                }
            }
            builder.create()
            builder.show()
        }
    }

    private fun deleteListItem(item: MainItem): Boolean {
        activity?.let {
            val builder = AlertDialog.Builder(activity)
            builder.apply {
                setTitle("Delete ${item.itemName}?")
                setPositiveButton(
                    "Yes"
                ) { _, _ ->
                    viewModel.deleteMainItem(item)
                    viewModel.deleteDetailsFromMain(item.id)
                }
                setNegativeButton(
                    "Cancel"
                ) { dialog, _ ->
                    dialog.cancel()
                }
            }
            builder.create()
            builder.show()
        }
        return true
    }
}
                    </code>
                </pre>
            </div>
            <div class="col-md-6 ">
                <h3><code>DetailListFragment</code></h3>
                <pre>
                    <code>
class DetailListFragment : Fragment() {
    private val viewModel: ListViewModel by activityViewModels {
        ListViewModel.ListViewModelFactory(
            (activity?.application as BaseApplication).database.mainItemDao(),
            (activity?.application as BaseApplication).database.detailItemDao(),
            )
    }
    private var _binding: FragmentDetailListBinding? = null
    private val binding get() = _binding!!
    private lateinit var adapter: DetailAdapter
    private val args: DetailListFragmentArgs by navArgs()

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        _binding = FragmentDetailListBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        // Add click listener to floating action button
        binding.fabMain.setOnClickListener {
            addListItem()
        }
        val recyclerView = binding.detailListView
        recyclerView.layoutManager = LinearLayoutManager(requireContext())

        // lambda to define longClick behavior
        val longClick = { detailItem: DetailItem ->
            deleteListItem(detailItem)
        }
        adapter = DetailAdapter(longClick)
        recyclerView.adapter = adapter
        viewModel.getDetailItems(args.mainItemId).observe(this.viewLifecycleOwner) { items ->
            items.let {
                adapter.submitList(it)
                adapter.notifyDataSetChanged()
            }
        }
    }

    private fun addListItem() {
        val input = EditText(activity)
        input.hint = "Item name"
        input.inputType = InputType.TYPE_CLASS_TEXT
        activity?.let {
            val builder = AlertDialog.Builder(activity)
            builder.apply {
                setTitle("Add List Item")
                setView(input)
                setPositiveButton(
                    "Add"
                ) { _, _ ->
                    viewModel.addDetailItem(args.mainItemId, input.text.toString())
                }
                setNegativeButton(
                    "Cancel"
                ) { dialog, _ ->
                    dialog.cancel()
                }
            }
            builder.create()
            builder.show()
        }
    }

    private fun deleteListItem(detailItem: DetailItem): Boolean {
        activity?.let {
            val builder = AlertDialog.Builder(activity)
            builder.apply {
                setTitle("Delete ${detailItem.detailItemName}?")
                setPositiveButton(
                    "Yes"
                ) { _, _ ->
                    viewModel.deleteDetailItem(detailItem)
                    Log.d("deletion", "id was $detailItem")
                }
                setNegativeButton(
                    "Cancel"
                ) { dialog, _ ->
                    dialog.cancel()
                }
            }
            builder.create()
            builder.show()
        }
        return true
    }
}
                    </code>
                </pre>
            </div>
        </div>
        <div class="row">
            <h3>Application Demonstration:</h3>
            <p> See the link at the bottom of this page to install this application onto your own device</p>
            <div class="pt-5"></div>
            <div class="col-md-6 text-center">
                <img alt="MainListFragment Screenshot" src="images/ListMaker/main.png" width="400">
            </div>
            <div class="col-md-6 text-center">
                <img alt="DetailListFragment Screenshot" src="images/ListMaker/groceries.png" width="400">
            </div>
        </div>
        <div class="pt-5"></div>
        <div class="row">
            <h3>Top Accomplishments:</h3>
            <p>
                Exploring mobile application development has been extrmely worthwhile and I would reccomend it to any CS student or
                anyone with an interest in programming. I have learned a lot about software architecture, testing, and
                design. I have been introduced to software design patterns and situations in which they are useful.
                Additionally, learning Kotlin gave me a better appreciation for object-oriented languages and why they
                are so commonly used in when developing applications. Before exploring mobile application development,
                I understood what interfaces and inherited classes were but wasn't sure when to use one over the other.
                In summary, developing mobile applications has allowed me to put into practice the computer science
                fundamentals I had a previous academic understanding of but in a more practical, real-world way.
            </p>
            <div class="pt-5"></div>
            <h3>What would I do differently?</h3>
            <p>
                I knew from past learning experiences that I would learn best by completing projects with minimal guidance
                as opposed to watching videos, reading documentation, or working through tutorials. For this reason,
                I wanted to develop my own applications as soon as possible. I attempted a few applications guided only
                by my own intuition and my past experience as a computer science student. These applications did not go
                very far and I soon realized I needed to complete some formalized training. The
                <a href="https://developer.android.com/courses/android-basics-kotlin/course">Android Basics in Kotlin Course</a>
                offered by Android was perfect. It consisted of six modules, and each module took about two weeks to complete.
                After finishing the training, I had a very good understanding of the basic components of building a
                well designed, useful, and appealing applications. I wish I had completed this course sooner.
            </p>
            <div class="pt-5"></div>
            <h3>Published Applications:</h3>
            <div class="row">
                <div class="col-md-6 text-center">
                    <h3>
                        <a href="https://github.com/harr1424/ListMaker">ListMaker</a>
                    </h3>
                    <p>
                        ListMaker is a native Android app useful for creating nested lists of items worth remembering.
                        This app
                        implements the Android Jetpack
                        <a href="https://developer.android.com/training/data-storage/room">Room Library</a>
                        in order to persistently store user created lists within a SQL
                        database on the user's device. This app also demonstrates the use of a ViewModel and
                        the
                        Android
                        <a href="https://developer.android.com/guide/navigation/navigation-getting-started">Navigation
                            Component</a>.
                    </p>
                    <img alt="Koradi App screenshot" class="mx-auto d-block" height="700"
                         src="images/ListMaker/groceries.png"/>
                    <br>
                    <a href='https://play.google.com/store/apps/details?id=com.harr1424.listmaker&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img
                            alt='Get it on Google Play'
                            height="100"
                            src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'/></a>
                    <a href="https://f-droid.org/packages/com.harr1424.listmaker/">
                        <img alt="Get it on F-Droid"
                             height="100"
                             src="https://fdroid.gitlab.io/artwork/badge/get-it-on.png">
                    </a>
                </div>
                <div class="col-md-6 text-center">
                    <h3>
                        <a href="https://github.com/harr1424/koradi_radio-master">Koradi App</a>
                    </h3>
                    <p>
                        The Koradi App is a Flutter project allowing users to interact with Koradi Radio. This
                        application
                        has been localized for six different languages and allows users to connect to a continuous audio
                        stream
                        originating from the Koradi Radio server. It implements a
                        <a href="https://pub.dev/packages/audio_service">background audio service</a>
                        in order to continuously play media, even when the app is not in the foreground
                    </p>
                    <img alt="Koradi App screenshot" class="mx-auto d-block" height="700" src="images/koradi.png"/>
                    <br>
                    <a href='https://play.google.com/store/apps/details?id=com.koradi.radio&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'
                       style="display: inline; overflow: hidden; border-radius: 23px; width: 250px; height: 100px;"><img
                            alt='Get it on Google Play'
                            height="100"
                            src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'/></a>
                    <a href="https://apps.apple.com/us/app/koradi-app/id1606623606?itsct=apps_box_badge&amp;itscg=30200"
                       style="display: inline; overflow: hidden; border-radius: 13px; width: 250px; height: 100px;"><img
                            alt="Download on the App Store"
                            src="https://tools.applemediaservices.com/api/badges/download-on-the-app-store/black/en-us?size=250x83&amp;releaseDate=1645142400&h=652fffa4f11b0f00c251d54e870e69a3"
                            style="width: 250px; height: 70px;"></a>
                </div>
            </div>
            <div class="pt-5"></div>
            <footer class="page-footer font-small blue">
                <div class="footer-copyright text-center py-3">
                    Google Play and the Google Play logo are trademarks of Google LLC.
                </div>
            </footer>
        </div>


        <!-- Option 1: Bootstrap Bundle with Popper -->
        <script crossorigin="anonymous"
                integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
                src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>