<!doctype html>
<html lang="en">

<head>

    <link rel="stylesheet" href="style.css">

    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <!-- Bootstrap CSS -->
    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet">

    <title>iOS Networking: Orange Weather</title>
</head>

<body>
<div class="container">
    <div class="row ">
        <div class="dropdown">
            <a class="btn btn-secondary btn-lg dropdown-toggle" href="#" role="button" id="dropdownMenuLink"
               data-bs-toggle="dropdown" aria-expanded="false">
                Portfolio Components
            </a>

            <ul class="dropdown-menu" aria-labelledby="dropdownMenuLink">
                <li><a class="dropdown-item" href="index.html">Home</a></li>
                <li>
                    <hr class="dropdown-divider">
                </li>
                <li><a class="dropdown-item" href="mobile_app_dev.html">Mobile Application Development</a></li>
                <li><a class="dropdown-item" href="cloud_computing.html">Cloud Computing</a></li>
                <li><a class="dropdown-item" href="3.html">Topic 3</a></li>
                <li><a class="dropdown-item" href="4.html">Topic 4</a></li>
                <li><a class="dropdown-item" href="5.html">Topic 5</a></li>
                <li><a class="dropdown-item" href="honorable_mentions.html">Honorable Mentions</a></li>
                <li><a class="dropdown-item" href="reflective_essay.html">Reflective Essay</a></li>
                <li><a class="dropdown-item" href="CV.html">Cirriculum Vitae</a></li>
                <li>
                    <hr class="dropdown-divider">
                <li><a class="dropdown-item" href="orange_weather.html">iOS Networking: Orange Weather</a></li>
                </li>

            </ul>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h3>A Brief Introduction to Swift</h3>
        <div class="col-md-g">
            <p>
                Orange Weather allows users to view current weather conditions as well as hourly and daily forecasts
                at their current location. It's development process provided a great opportunity to learn more about
                Swift, SwiftUI, and how to receive API data within an iOS app. Having previously created apps written in
                Kotlin and Dart, a lot of the Swift syntax and functionality seemed familiar. All three languages are
                strongly typed, differentiate between mutable and immutable variables, and provide a means of
                implementing
                anonymous functions (known as <a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html">closures</a>
                in Swift). Out of the three languages mentioned above, Swift quickly became my favorite as it has some
                features that make life so much easier!
            </p>
            <p>
                To start, I was delighted that similar to C++, Swift allows for object-oriented programming through the
                use
                of
                not only classes, but also structs. In Swift, both structs and classes are used to create objects that
                contain members and/or functions related in some way. Classes are able to inherit attributes from other
                classes,
                but inheritance is not a capability among structs. Structs are also said to be immutable, meaning that
                if a
                given struct is modified, instead of changing a variable at a location in memory allocated to the
                struct,
                an entirely new struct will be created with the updated variable. An example of this is below:
            </p>
        </div>

        <code>
            <pre>
            struct Cat {
                let _class = "Mammal" // _class is immutable, a spoecies can't change class
                var paws: Int
                var tail: Bool
                var color: String
            }

            var CremePuff = Cat(paws: 4, tail: true, color: "beige")
            CremePuff.paws = 3 // Creampuff will be copied and the variable paws set to 3 in the fresh copy

            let Granpa = Cat(paws: 4, tail: true, color: "unknown")
            Granpa.color = "black" // this will not compile because Granpa was defined as immutable using the let keyword
            </pre>
        </code>

        <P>
            * <code>_class</code> is prefixed with an underscore because <code>class</code> is a keyword in Swift
            <br>
            <a href="https://en.wikipedia.org/wiki/Creme_Puff_(cat)">Who are CremePuff and Granpa?</a>
        </P>

        <p>
            Another very welcome feature in Swift is the ability to <i>extend</i> types (either built-in or custom)
            through
            the use of <a href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html">extensions</a>. Since
            structs
            are a type, this allows us to extend the functionality of our structs in situations where this is desirable,
            and by using the <code>private</code> keyword, we can contain the effect this extension has within a single
            module.
        </p>
        <code>
            <pre>
                extension Cat {
                    func meow() {
                         print("Meow")
                        }
                    }

                Granpa.meow()
            </pre>
        </code>

        <p>
            The code above will print: <code>Meow</code>
        </p>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h3>First Impressions of SwiftUI</h3>
        <p>
            SwiftUI was released by Apple in 2019 as an updated way to build user interfaces in a declarative form.
            Apple has invested heavily in developing and promoting the adoption of SwiftUI as it provides a way to
            design
            user interfaces across all Apple devices (as opposed to selecting UIKit for iOS devices or AppKit for Mac
            OS X). SwiftUI contains all of the same user interface (UI) elements I became familiar using in Storyboard
            layouts such as `UIButton` and `UITableView` but provides for a different way of implementing these elements
            within an app.
        </p>
        <p>
            It might just be me, but it seems like declarative programming frameworks have been gaining a lot of
            momentum
            over the past several years. Android also released a declarative framework for building apps called
            <a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a> in 2019. Declarative programming
            describes a modaility of programming where the desired outcome is described using code, and a compiler or
            framework is responsible for accomplishing this outcome. Imperative programming refers to a programmer
            explicitly
            specifying how to accomplish an outcome in a step-by-step process. Previously, I have used
            <a href="https://www.terraform.io/">Terraform></a> to provision cloud infrastructure, and so the declarative
            concept was a familiar one.
        </p>
        <p>
            In addition to providing a cross platofrm means of defining application layouts using a declarative
            framkework,
            SwiftUI also simplifies application state management. The state of an application
            can change very rapidly, especially in apps that are performing work with data retrieved from internet.
            SwiftUI abstracts away much of an application's state management, and
            this will be explored in greater detail below. Additionally, SwiftUI is
            <a href="https://developer.apple.com/xcode/swiftui/">constantly being updated</a> in order to
            provide improved access to Apple APIs.
        </p>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h3>Orange Weather: The App</h3>
        <div class="col-md-6">
            <ul>
                <li>
                    The entry point to the application is stored in a struct named <code>Orange_WeatherApp</code>.
                </li>
                <li>
                    This struct is annotated with <code>@main</code> to identify it as the main view
                </li>
                <li>
                    This struct is used to inform the app to display <code>MainWeatherView</code> once the app is
                    initialized
                </li>
            </ul>
        </div>
        <div class="col-md-6">
            <code>
                <pre>
import SwiftUI

@main
struct Orange_WeatherApp: App {
    var body: some Scene {
        WindowGroup {
            MainWeatherView()
        }
    }
}
                </pre>
            </code>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6">
            <ul>
                <li>
                    The <code>MainWeatherView</code> struct is the initial point of entry that a user has with the app.
                    As
                    such it has been designed to respond immediately if a user is not connected to the internet or if
                    they have not granted location permissions to the app. In order to perform these checks, methods
                    have been defined in two classes <code>Networking</code> and <code>NetworkStatus</code>.
                </li>
                <li>
                    <code>Networking</code> will be examined in detail below, but contains members and methods which are
                    related to device location, permissions, and requesting information from the OpenWeather API.
                </li>
                <li>
                    <code>NetworkStatus</code> contains members and methods solely related to the connectivity status
                    of the device.
                </li>
                <li>
                    Both instances have been annotated as <code>@StateObject</code>. SwiftUI allows structs and classes
                    to publish members which can then be observed by other structs or classes. If a struct or class
                    observes an object that it instantiates, the <code>@StateObject</code> annotation should be used. If
                    an
                    observable object is then later passed into another class, that referencing class should annotate
                    the
                    observed object with the <code>ObservedObject</code> annotation.
                </li>
                <li>
                    Apple provides the <code>CLLocationManager</code> API that developers can use to interface with a
                    device location. This API sends and receives location information using the
                    <code>CLLocationDegrees</code> data type.
                </li>
                <li>
                    The <code>update()</code> helper method is used to perform API requests anytime the UI should be
                    updated
                    to show the most recent weather data.
                </li>
                <li>
                    In SwiftUI, a <code>View</code> is a protocol. Structs and classes are said to <i>conform</i> to
                    protocols. (Protocols are analagous to interfaces in Java and Kotlin).
                    In order for a given view to conform to the <code>View</code> protocol, it must implement a variable
                    named <code>body</code> which describes the view.
                </li>
                <li>
                    The declaration <code>var body: some View { ...</code> may seem confusing at first. This declaration
                    defines the <code>body</code> attribute necessary for <code>MainWeatherView</code> to conform to the
                    <ciode>View</ciode>
                    protocol. But since <code>body</code> is a variable and not a class, struct, or
                    enumeration, the syntax <code>var body: some View</code> means that the variable <code>body</code>
                    is <i>some</i> type of view. It could be a <code>UITextView</code>, a <code>UITableView</code>, or
                    any other type of view, but declaring its type as a <code>View</code> is essential for the compiler
                    operations
                    that allow SwiftUI to update UI elements so quickly.
                </li>
                <li>
                    Immediately upon the view being displayed, Orange Weather checks to see if the user device is
                    connected
                    to the internet, and if it is not, an error message will be shown to the user explaining why an
                    internet connection is required.
                </li>
                <li>
                    A similar check is performed for location based permissions. Orange Weather requires a user's
                    location
                    in order to obtain current weather information at that location. Thus, at a minimum, a user must
                    grant permission to the app to access device location while the app is in use. The first time that
                    the app
                    runs on a user device, they will be prompted with the following: <br><br>

                    <img src="images/OrangeWeather/loc.png" alt="Location permission prompt" width="400" class="center">

                </li>
                <li>
                    If they fail to select "Allow Once" or "Allow While Using App" a view describing the problem will be
                    shown. This view is visible in tha background until the user makes a decision.
                </li>
                <li>
                    The UI content which is intended to be displayed assuming a device is connected to the internet and
                    a user grants the necessary permissions has been wrapped inside a <code>NavigationView</code> which
                    has several benefits:
                    <ul>
                        <li>
                            Each navigation screen is now given a title, and in the case of the main view I have
                            programmatically
                            set the title to match the current device location
                        </li>
                        <li>
                            Subsequent views navigated to will also be assigned titles, and a back arrow will appear
                            at the top of the screen next to the title allowing the user to easily navigate back to the
                            main view.
                        </li>
                        <li>
                            NavigationViews provide a lot of accessibility configuration options to make navigating the
                            app
                            easier for all persons.
                        </li>
                    </ul>
                </li>
                <li>
                    If all goes well, our application should quickly load the following View: <br><br>
                    <img src="images/OrangeWeather/mainView.png" alt="Location permission prompt" width="400"
                         class="center">

                </li>
            </ul>
        </div>
        <div class="col-md-6">
            <code>
                <pre>
import SwiftUI
import CoreLocation

/* The initial View shown in the application. From here, a user
 is able to see current weather information as well as navigate to other
 views of the app. If a user is not connected to the internet, or
 has not granted location permissions to this app, the view will
 display an error message. */
struct MainWeatherView: View {

    /* State objects are used here as opposed to ObservedObjetcs since
     these objects are being instantiated in this class*/

    @StateObject var network = Networking()  // object containing location and weather information
    @StateObject var networkConn = NetworkStatus()  // object containing network connectivity status

    var lat: CLLocationDegrees {
        return self.network.lastLocation?.coordinate.latitude ?? 0
    }

    var lon: CLLocationDegrees {
        return self.network.lastLocation?.coordinate.longitude ?? 0
    }

    var locationString: String {
        return self.network.locationString?.name ?? "Orange Weather"
    }

    func update(lat: CLLocationDegrees, lon: CLLocationDegrees) {
        self.network.getLocationString(lat, lon)
        self.network.getMainWeather(lat, lon)
        self.network.getAQI(lat, lon)
    }


    var body: some View {

        // If a user is not connected to the internet
        if !networkConn.isConnected {
            Image(systemName: "antenna.radiowaves.left.and.right")
                .resizable()
                .aspectRatio( contentMode: .fit)
                .scaleEffect(0.75)
                .foregroundColor(.blue)
            Text("""
            You currently are not connected to the internet. Please connect to Wi-Fi or cellular data in order to use this app.
            """)
            .fontWeight(.bold)
            .font(.system(size: 24))
            .foregroundColor(.blue)
            .multilineTextAlignment(.center)
            .padding()
        }

        // If a user has not granted location permissions while the app is in use
        else if !network.permissions {
            Image(systemName: "tornado")
                .resizable()
                .aspectRatio( contentMode: .fit)
                .scaleEffect(0.75)
                .foregroundColor(.blue)
            Text("""
            This app requires permission to access your location while the app is in use. It will not work otherwise. Your location
            data is never shared with nor stored by the developer. Please grant location permissions to this app from the settings menu.
            """)
            .fontWeight(.bold)
            .font(.system(size: 24))
            .foregroundColor(.blue)
            .multilineTextAlignment(.center)
            .padding()

        } else {  // Display the intended view

            NavigationView {
                VStack {
                    if let response = network.weatherResponse {
                        Image(systemName: WeatherModel.getConditionName(weatherID: (response.current.weather[0].id)))
                            .resizable()
                            .aspectRatio( contentMode: .fit)
                            .scaleEffect(0.75)
                            .foregroundColor(WeatherModel.getIconColor(weatherID: response.current.weather[0].id))
                    }

                    HStack {

                        VStack{
                            Text("Temperature")
                                .fontWeight(.bold)
                                .font(.system(size: 24))
                            Text("Wind")
                                .fontWeight(.bold)
                                .font(.system(size: 24))
                            Text("Humidity")
                                .fontWeight(.bold)
                                .font(.system(size: 24))
                            Text("Dew Point")
                                .fontWeight(.bold)
                                .font(.system(size: 24))
                            Text("UV Index")
                                .fontWeight(.bold)
                                .font(.system(size: 24))
                            Text("Air Quality")
                                .fontWeight(.bold)
                                .font(.system(size: 24))
                            Spacer()
                        }

                        VStack {
                            if let response = network.weatherResponse {
                                Text("\(response.current.temp, specifier: "%.0f")°F")
                                    .fontWeight(.bold)
                                    .font(.system(size: 24))
                                Text("\(response.current.wind_speed, specifier: "%.0f") mph from \(WeatherModel.getWindDirection(degree: response.current.wind_speed))")
                                    .fontWeight(.bold)
                                    .font(.system(size: 24))
                                Text("\(response.current.humidity, specifier: "%.0f") %")
                                    .fontWeight(.bold)
                                    .font(.system(size: 24))
                                Text("\(response.current.dew_point, specifier: "%.2f") °F")
                                    .fontWeight(.bold)
                                    .font(.system(size: 24))
                                Text("\(response.current.uvi, specifier: "%.0f")  \(WeatherModel.getUvIndexCategory(uvIndex: response.current.uvi))")
                                    .fontWeight(.bold)
                                    .font(.system(size: 24))
                            }
                            if let response = network.currAQI {
                                Text(WeatherModel.getAQIstring(aqi: response.list[0].main.aqi))
                                    .fontWeight(.bold)
                                    .font(.system(size: 24))
                            }
                            Spacer()
                        }
                    }
                    HStack {
                        NavigationLink(destination: HourlyWeatherView(hourly: network.weatherResponse?.hourly)) {
                            ButtonView(text: "Hourly")
                        }
                        NavigationLink(destination: WeatherAlertView(alerts: network.weatherResponse?.alerts)) {
                            ButtonView(text: "Alerts")
                        }
                        NavigationLink(destination: DailyWeatherView(daily: network.weatherResponse?.daily)) {
                            ButtonView(text: "Daily")
                        }
                    }
                }
                .navigationTitle(locationString)
                .environmentObject(network)
                .onAppear {
                    /* Depending upon netowrk latency, the weather information, location string, and air quality index
                     may not have been retrieved and/or decoded by the time the view appears. If lat and lon are still nil,
                     update the UI*/
                    if lat == 0 && lon == 0 {
                        DispatchQueue.main.asyncAfter(deadline: .now() + 2, execute: {
                            self.update(lat: lat, lon: lon)
                        })
                    }
                    self.update(lat: lat, lon: lon)
                }
            }
        }
    }
}

                </pre>
            </code>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h3>Additional Views:</h3>
        <p>
            Orange Weather's <code>MainWeatherView</code> displays current weather information and also links to
            additional views describing
            the hourly forecast, daily forecast, and any currently issued weather alerts. To implement these secondary
            views,
            it is first necessary to define them as a <code>struct</code> specifying what information is shown in each
            view. This process is shown below for an <code>HourlyView</code> (below left). Once
            <code>HourlyView</code> has been defined, it is then possible to create a list of <code>HourlyView</code>
            views
            useful for displaying many forecasted hourly conditions, each displayed in their own view. The process of
            creating this <code>List</code> view is shown below on the right.
        </p>
        <div class="col-md-6">
            <code>
                <pre>
/* A View used to display weather infromation specific to a given hour.
 Multiple HourlyView Views will be displayed in a list. */

struct HourlyView: View {
    let calendar = Calendar.current
    var hourly: Hourly

    var body: some View {
        HStack {
            VStack {
                Spacer()
                Text("\(WeatherModel.getWeekDay(day: Int(calendar.component(.weekday, from: NSDate(timeIntervalSince1970: TimeInterval(hourly.dt)) as Date))))")
                    .fontWeight(.bold)
                Text("\(WeatherModel.getTimeAs12hr(hour: Int(calendar.component(.hour, from: NSDate(timeIntervalSince1970: TimeInterval(hourly.dt)) as Date))))")
                    .fontWeight(.bold)
                Spacer()
                Text("\(hourly.temp, specifier: "%.0f")°F")
                    .fontWeight(.bold)
                Spacer()
            }
            Image(systemName:  WeatherModel.getConditionName(weatherID: hourly.weather[0].id))
                .resizable()
                .aspectRatio( contentMode: .fit)
                .scaleEffect(0.75)
                .foregroundColor(WeatherModel.getIconColor(weatherID: hourly.weather[0].id))
            VStack {
                Spacer()
                Text("Wind \(hourly.wind_speed, specifier: "%.0f") mph \(WeatherModel.getWindDirection(degree: hourly.wind_deg))")
                Spacer()
                Text("\(hourly.pop * 100, specifier: "%.0f")% chance of \(WeatherModel.getRainorSnow(temp: hourly.temp))")
                Spacer()
            }
        }
    }
}
                </pre>
            </code>
        </div>
        <div class="col-md-6">
            <code>
                <pre>
/* A View describing the hourly forecast for a given location. */

struct HourlyWeatherView: View {

    var hourly: [Hourly]?

    var body: some View {
        if let currHourly = hourly {
            List(currHourly) { forecast in
                HourlyView(hourly: forecast)
            }
            .navigationTitle("Hourly")

        } else {
            Image(systemName: "questionmark")
                .resizable()
                .aspectRatio( contentMode: .fit)
                .scaleEffect(0.75)
                .foregroundColor(.blue)
            Text("Something went wrong... ")
                .fontWeight(.bold)
                .font(.system(size: 24))
                .foregroundColor(.blue)
                .multilineTextAlignment(.center)
            Spacer()
                .navigationTitle("Hourly")
        }
    }
}
                </pre>
            </code>
        </div>
        <p>
            This same process of defining a base view and then creating a <code>List</code> consisting of base views has
            been repeated for both <code>AlertView</code> and <code>DailyView</code> views. Full source code can be
            found on the project's <a href="https://github.com/harr1424/Orange-Weather">GitHub repository</a>.
        </p>
        <div class="col-md-4">
            <img src="images/OrangeWeather/hourly.png" alt="List of HourlyView views composing an hourly forecast view"
                 width="350" class="center">
        </div>
        <div class="col-md-4">
            <img src="images/OrangeWeather/alerts.png" alt="List of HourlyView views composing an hourly forecast view"
                 width="350" class="center">
        </div>
        <div class="col-md-4">
            <img src="images/OrangeWeather/daily.png" alt="List of DailyView views composing an daily forecast view"
                 width="350" class="center">
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h3>Networking: </h3>
        <p>
            The most difficult part of creating Orange Weather involved retrieving a device's current location and
            using this location in subsequent API calls. The class examined below contains logic to accomplish this:
        </p>
        <div class="col-md-6">
            <ul>
                <li>
                    Our networking class needs to expose the results of its API calls. This is done by annotating
                    the objects that will be observed in the UI by using the <code>@Published</code> annotation. Note
                    that
                    these objects have been defined in a separate file, which will be examined later. Most importantly,
                    when
                    defining these objects as structs, they must conform to the <code>Observable Object</code>
                    protocol in order to be published and observed.
                </li>
                <li>
                    THe overridden <code>init()</code> method is responsible for setting the location manager delegate
                    property to be itself. <a href="https://en.wikipedia.org/wiki/Delegation_pattern"> The delegae
                    pattern</a>
                    is very common in iOS development, and many of Apple's APIs implement this pattern. Effectively,
                    by setting the current class as the location manager delegate, we are allowing this class to respond
                    to
                    permission changes, handle errors, respond to location events, and in general control the
                    functioning
                    of the <code>CLLocationManager</code> API instance. Also in <code>init()</code>, the desired
                    location
                    is set to an area reasonable for obtaining accurate weather data, adequate permissions are requested
                    of the user, and the instance is instructed to begin updating the user's location.
                </li>
                <li>
                    It is essential to account for the location permissions currently granted to Orange Weather by the
                    user.
                    If the user has not granted adequate permissions, our API calls will not return data in the expected
                    format and if this is not handled our app will crash. We will explore additional ways to
                    gracefully handle an unexpected API response, but only calling API endpoints once we are certain
                    that
                    a device has the correct lat lon coordinates is an important first step.
                </li>
                <li>
                    The first time a user launches Orange Weather, the location permissions granted to the app are
                    <code>.notDetermined</code>. Hopefully, the user grants permission to the app to access device
                    location
                    while the app is in use, but this will take a few moments. Once a user has decided whether or not to
                    grant permissions, the <code>didChangeAuthorizations</code> method will be called, which will in
                    turn
                    update the variables in <code>Networking</code> responsible for tracking current permission status.
                </li>
                <li>
                    Once the instance of <code>CLLocatinManager</code> updates the <code>lastLocation</code> property
                    the
                    method <code>didUpdateLocations</code> will be called. Since our <code>Networking</code> cass is set
                    as the delegate for this instance, we are able to define what should happen once location has been
                    updated.
                    Here, we have instructed the app to perform API calls that will update the published properties
                    that are being observed in the UI. Once this completes, we instruct <code>CLLocationManager</code>
                    to
                    stop updating the device location. If we did not do this, the app would continuously update the
                    device
                    location every few seconds and perform three API calls each time, and so we would quickly exceed
                    our limited available API calls (OpenWeather limits to 60 API calls per minute at their free tier).
                </li>
                <li>
                    Lastly, the three API calls are defined: <code>getMainWeather</code> loads data representing
                    current weather conditions into a published object, <code>getLocationString</code> loads a
                    string representation of the user's current location into a published object, and
                    <code>getAQI</code> does the same for the current Air Quality Index.
                </li>
                <li>
                    Each function defines a string representation of an API request. This string is used to create a
                    <code>URLSession</code> in order to send a request and process a response. This response will
                    consist
                    of JSON data which will need to be decoded into a series of <code>struct</code> representations of
                    that
                    data. Assuming all goes well, the response will be decoded and the data will be used to update
                    the UI. Note that this last step is performed on the main thread
                    <code>DispatchQueue.main.async</code> will ensure that once this data is available, it will be
                    updated on the main thread, the thread devoted to UI updates.
                </li>
                <li>
                    An identical process occurs for <code>getLocationString</code> and <code>getAQI</code>
                </li>
                <li>
                    Next, we will examine how to define structs in order to decode the JSON response.
                </li>
            </ul>
        </div>
        <div class="col-md-6">
            <code>
                <pre>
class Networking: NSObject, ObservableObject, CLLocationManagerDelegate {

    @Published var weatherResponse: WeatherResponse?
    @Published var locationString: LocationResponse?
    @Published var currAQI: AQIresponse?

    private let locationManager = CLLocationManager()
    @Published var locationStatus: CLAuthorizationStatus?
    @Published var lastLocation: CLLocation?

    override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyHundredMeters
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
    }

    var statusString: String {
        guard let status = locationStatus else {
            return "unknown"
        }

        switch status {
        case .notDetermined: return "notDetermined"
        case .authorizedWhenInUse: return "authorizedWhenInUse"
        case .authorizedAlways: return "authorizedAlways"
        case .restricted: return "restricted"
        case .denied: return "denied"
        default: return "unknown"
        }
    }

    var permissions: Bool {
        switch statusString {
        case "notDetermined": return false
        case "authorizedWhenInUse": return true
        case "authorizedAlways": return true
        case "restricted": return false
        case "denied": return false
        default: return false
        }
    }

    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        locationStatus = status
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        lastLocation = location
        getMainWeather(self.lastLocation?.coordinate.latitude ?? 0, self.lastLocation?.coordinate.longitude ?? 0)
        getLocationString(self.lastLocation?.coordinate.latitude ?? 0, self.lastLocation?.coordinate.longitude ?? 0)
        getAQI(self.lastLocation?.coordinate.latitude ?? 0, self.lastLocation?.coordinate.longitude ?? 0)
        locationManager.stopUpdatingLocation()
    }

    func getMainWeather(_ lat: CLLocationDegrees, _ lon: CLLocationDegrees) {
        if let loc = URL(string: "https://api.openweathermap.org/data/2.5/onecall?appid=REDACTED&exclude=minutely&units=imperial&lat=\(lat)&lon=\(lon)") {
            let session = URLSession(configuration: .default)
            let task = session.dataTask(with: loc) { data, response, error in
                if error == nil {
                    let decoder = JSONDecoder()
                    if let safeData = data {
                        do {
                            let results = try decoder.decode(WeatherResponse.self, from: safeData)
                            DispatchQueue.main.async {
                                self.weatherResponse = results
                            }
                            print("weatherResponse was succesfully updated for \(lat) \(lon)")
                        } catch {
                            print(error)
                        }
                    }
                } else {
                    print(error!)
                }
            }
            task.resume()
        }
    }

    func getLocationString(_ lat: CLLocationDegrees, _ lon: CLLocationDegrees) {
        if let loc = URL(string: "https://api.openweathermap.org/data/2.5/weather?appid=REDACTED&exclude=minutely&units=imperial&lat=\(lat)&lon=\(lon)") {
            let session = URLSession(configuration: .default)
            let task = session.dataTask(with: loc) { data, response, error in
                if error == nil {
                    let decoder = JSONDecoder()
                    if let safeData = data {
                        do {
                            let results = try decoder.decode(LocationResponse.self, from: safeData)
                            DispatchQueue.main.async {
                                self.locationString = results
                            }
                            print("Location was succesfully updated for \(lat) \(lon)")
                        } catch {
                            print(error)
                        }
                    }
                } else {
                    print(error!)
                }
            }
            task.resume()
        }
    }

    func getAQI(_ lat: CLLocationDegrees, _ lon: CLLocationDegrees) {
        if let loc = URL(string: "https://api.openweathermap.org/data/2.5/air_pollution?appid=REDACTED&exclude=minutely&lat=\(lat)&lon=\(lon)") {
            let session = URLSession(configuration: .default)
            let task = session.dataTask(with: loc) { data, response, error in
                if error == nil {
                    let decoder = JSONDecoder()
                    if let safeData = data {
                        do {
                            let results = try decoder.decode(AQIresponse.self, from: safeData)
                            DispatchQueue.main.async {
                                self.currAQI = results
                            }
                            print("AQI was succesfully updated for \(lat) \(lon)")
                        } catch {
                            print(error)
                        }
                    }
                } else {
                    print(error!)
                }
            }
            task.resume()
        }
    }

}

                </pre>
            </code>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h3>Decoding JSON in Swift</h3>
        <p>
            I was delighted with the simplicity involved in decoding the JSON response in Swift. This process is
            considerably
            more straightforward than what I was accustomed to in Android, which required the use of third party
            libraries
            such as RetroFit and Moshi. In Swift, it is sufficient to examine the API response and construct
            <code>struct</code> objects containing the properties you wish to decode. This is something I would have
            definitley taken for granted if I had not formerly used RetroFit and Moshi, which require every JSON
            response field
            to be declared inside some object. The below code demonstrates what the response returned by the API
            endpoint
            called in <code>getMainWeather</code> will look like. Note that for the sake of readability, only the
            elements contained in the <code>current</code> array have been copied. <code>hourly</code> and
            <code>daily</code> are arrays containing a large number of similarly structured elements.
        </p>
        <div class="col-md-4"></div>
        <div class="col-md-4">
            <code>
            <pre>
  "lat": 46.8721,
  "lon": -113.994,
  "timezone": "America/Denver",
  "timezone_offset": -21600,
  "current": {
    "dt": 1655513488,
    "sunrise": 1655466057,
    "sunset": 1655523177,
    "temp": 75.79,
    "feels_like": 74.95,
    "pressure": 1002,
    "humidity": 40,
    "dew_point": 49.78,
    "uvi": 1.18,
    "clouds": 0,
    "visibility": 10000,
    "wind_speed": 17.27,
    "wind_deg": 240,
    "wind_gust": 25.32,
    "weather": [
      {
        "id": 800,
        "main": "Clear",
        "description": "clear sky",
        "icon": "01d"
      }
    ]
  },
  "hourly": [...],
  "daily": [...],
}
            </pre>
            </code>
        </div>
        <div class="col-md-4"></div>
        <p>
            Examining this response, we can cherry pick the elements that will be most useful for our app and create
            structs to receive these elements:
        </p>
        <div class="col-md-6">
            <ul>
                <li>
                    Notice in the code for <code>getMainWeather()</code> that the <code>JSONDecoder</code> expects
                    a parameter <code>WeatherResponse.self</code>. This refers to a <code>WeatherResponse</code> struct
                    that the decoder will use to map the JSON data to. The <code>self</code> keyword is necessary
                    because the <code>WeatherResponse</code> struct is referenced from within a closure. More about this
                    can be found <a href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html#ID546">here</a>.
                </li>
                <li>
                    In this explanation, we are concerned with the JSON response contained in the <code>current</code>
                    array as shown above. Our <code>WeatherResponse</code> struct has now declared properties
                    corresponding
                    to the JSON response elements we are interested in, including <code>current</code>. Next, we must
                    create structs to receive the elements nested inside of the <code>current</code> array.
                </li>
            </ul>
        </div>
        <div class="col-md-6">
            <code>
                <pre>
struct WeatherResponse: Decodable{
    let current: Current
    let hourly: [Hourly]
    let daily: [Daily]
    let alerts: [Alert]?
}
                </pre>
            </code>
        </div>
        <div class="pt-5"></div>
        <div class="row">
            <div class="col-md-6">
                <ul>
                    <li>
                        The <code>Current</code> struct has declared attributes for each field we are interested in
                        using
                        from the JSON response. Note that <code>weather</code> is of type <code>Weather</code> array,
                        and
                        so we need to define one last <code>Weather</code> struct to describe an individual <code>Weather</code>
                        element. The only nested element we are intered in is <code>id</code>, an integer that
                        represents
                        a weather condition (i.e. rain, clouds, sun, wind, etc.) This element will be used to display
                        an icon that best represents current or forecasted weather conditions.
                    </li>
                    <li>
                        Lastly it is important to note that each struct we intend to use for JSON decoding must
                        conform to the <code>Decodable</code> protocol. This makes things considerably easier, as the
                        protocol handles the process of decoding JSON response data into standard library types such as
                        strings, integers, and doubles automatically.
                    </li>
                    <li>
                        Provided that all of our defined <code>struct</code> attributes can be penultimately mapped to
                        Standard Library types, this is all that is required. When woprking with custom types, it is
                        possible to define the decoding process using
                        <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types"
                        >Coding Keys</a>
                    </li>
                </ul>
            </div>
            <div class="col-md-6">
                <code>
                    <pre>
struct Current: Decodable {
    let temp: Double
    let humidity: Double
    let uvi: Double
    let wind_speed: Double
    let wind_deg: Double
    let dew_point: Double
    let weather: [Weather]
}

struct Weather: Decodable{
    let id: Int
}
                    </pre>
                </code>
            </div>
        </div>
        <p>
            A similar procedure has been followed to define structs that will receive the other elements of the JSON
            response
            used in Orange Weather. We are almost done, lastly we will examine some helper methods that enhance the
            user experience of this app.
        </p>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <h3>Helper Methods and UI Improvements</h3>
        <p>

        </p>
    </div>

</div>
<div style="text-align: center">
    <h3><a href="#">Top Of Page</a></h3>
</div>