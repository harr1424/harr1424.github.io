<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <!-- Bootstrap CSS -->
    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet">

    <link href="style.css" rel="stylesheet"/>

    <title>Mobile Application Development</title>
</head>
<body>
<div class="container">
    <div class="row ">
        <h1><a href="index.html">jharrington.dev</a></h1>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>Mobile Application Development</h3>
            <p>Eager to learn more about software development, and disappointed by the course offerings at UMT,
                I was fortunate to work with Patricia Duce in order to complete an Android Developer
                <a href="https://developer.android.com/courses/android-basics-kotlin/course">training course</a>
                and use the material contained therein to develop a course taught for the first time at UMT in Fall,
                2022.
            </p>
            <br>
            <h3>What I've Learned: Application Fundamentals</h3>
            <p>
                Android development has been an excellent way to get hands on practice writing clean code and
                work with software architecture patterns commonly found in industry applications,
                especially <i>model-view-viewmodel (
                <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVMM</a></i>) which is
                <a href="https://developer.android.com/jetpack/guide">endorsed</a> as a best practice
                when building Android apps.
            </p>
            <p> According to Android:</p>
            <blockquote CITE="https://developer.android.com/jetpack/guide"><I>
                Another important principle is that you should drive your UI from data models, preferably persistent
                models.
                Data models represent the data of an app. They're independent of the UI elements and other components
                in your app. This means that they are not tied to the UI and app component lifecycle, but will still be
                destroyed when the OS decides to remove the app's process from memory.
            </I></blockquote>
            <p>
                This effectively separates the application into two layers: a user-interface (UI) layer, and
                a data layer. This concept is just one example of various design principles that I learned while
                exploring application development.
            </p>
            <p>
                While Android applications have historically been written in Java, in May 2019 Google announced
                that the officially supported language for Android development would be
                <a href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)">Kotlin</a>.
                Kotlin has much in common with Java but its syntax has been changed to support type inference and
                eliminate the terminating semicolons, among many other features such as inline lambda functions,
                null safety, range expressions, and coroutines, all of which were explored in depth in the
                <a href="https://developer.android.com/courses/android-basics-kotlin/course">training course</a>.
            </p>
            <p>
                This course also emphasised the importance of testing application code, and each module contained an
                activity related to writing effective unit and functional tests.
                After teaching foundational concepts such as user interface (UI) management using layout resource files,
                click listeners, etc. the course demonstrated how to implement a
                <a href="https://developer.android.com/guide/topics/ui/layout/recyclerview">Recycler View</a>.
                Recycler Views are the component inside of Android applications that allow for an infinitely scrollable
                list.
                Think of any 'feed' you have encountered such as news feed on LinkedIn or Twitter, and you have the
                idea..
                Recycler Views have been designed to provide a user-friendly
                experience by scrolling smoothly and not freezing or jerking as fresh list items are loaded into the
                list.
            </p>
            <p>
                THe following is a code snippet from my application <i>ListMaker</i> which demonstrates the use of a
                Recycler View. Its individual components will be explained below:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
class MainAdapter(
    private val onItemClick: (MainItem) -> Unit, private val onItemLongClick: (MainItem) -> Boolean
) : ListAdapter<MainItem, MainAdapter.ViewHolder>(DiffCallback) {

    companion object DiffCallback : DiffUtil.ItemCallback<MainItem>() {
        override fun areItemsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem.itemName == newItem.itemName
        }

        override fun areContentsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem == newItem
        }

    }

    class ViewHolder(private var binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bind(item: MainItem) {
            binding.listItemText.text = item.itemName.toString()
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val viewHolder = ViewHolder(
            ListItemBinding.inflate(
                LayoutInflater.from(parent.context),
                parent,
                false
            )
        )
        viewHolder.itemView.setOnClickListener {
            val position = viewHolder.adapterPosition
            onItemClick(getItem(position))
        }
        viewHolder.itemView.setOnLongClickListener {
            val position = viewHolder.adapterPosition
            onItemLongClick(getItem(position))
        }
        return viewHolder
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <div class="pt-3"></div>
            <ul>
                <li>
                    The <i>MainAdapter</i> class constructor expects as arguments two click listeners that determine
                    what occurs if a list item is clicked or long-clicked respectively and extends the
                    <i>ListAdapter</i>
                    class which expects a <i>DifCallback</i> object as an argument.
                </li>
                <li>
                    <i>ListAdapter</i> is a base class used for presenting list data in a Recycler View.
                </li>
                <li>
                    <i>DiffCallback</i> is a class that contains methods for computing the difference between two lists
                    and is useful to detect when only one or a few list elements have changed, and update only those
                    elements as opposed to the entire list. Here <i>DiffCallback</i> is implemented as a
                    <a href="https://kotlinlang.org/docs/object-declarations.html#companion-objects">companion
                        object</a>.
                </li>
                <li>
                    A companion object is an example of the <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton
                    design pattern</a>
                    and also resemble static objects in Java in the sense that they belong to a specific class but not
                    a given instance of that class.
                </li>
                <li>
                    The <code>ViewHolder</code> class accepts a <code>ListItemBinding</code> object as an argument. A
                    <code>ListItem</code> has been defined
                    in a separate xml file and in this case contains only instructions on how to display a text field.
                    The <code>ViewHolder</code> class is responsible for using this binding object to set
                    the text field of a given
                    list item to the appropriate item's name in the <code>bind</code> function.
                </li>
                <li>
                    The <code>onCreateViewHolder</code> function returns a <code>ViewHolder</code> and is responsible
                    for
                    <a href="https://developer.android.com/reference/android/view/LayoutInflater">inflating</a> the
                    <code>ListItem</code> view.
                </li>
                <li>
                    Additionally two click listeners are set within <code>onCreateViewHolder</code>. Additionally
                    listeners can be set here as well that handle the application's response to specific gestures
                    or other events.
                </li>
                <li>
                    Lastly, the <code>onBindViewHolder</code> function is responsible for performing the work defined
                    in <code>onCreateViewHolder</code> and therefore also any work defined in the <code>bind</code>
                    function in the <code>ViewHolder</code> constructor. In this case this entails setting a
                    <code>ListItem</code>'s text field to the appropriate item's name and setting two click listeners.
                </li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: Application Navigation</h3>
            <p>
                Android provides a
                <a href="https://developer.android.com/guide/navigation/navigation-getting-started">Navigation
                    Component</a>
                which is intended to simply the process of navigating between views within an application. In Android,
                any screen displayed to a user is a view that has been defined in a <code>layout.xml</code> file. These
                views can
                be either activities or fragments. Simple applications can usually be contained within a single activity
                and make use of fragments to display different views. Utilizing the Navigation Component in such a
                situation is described below. The code for these examples has been taken from my solution to a
                <a href="https://developer.android.com/codelabs/basic-android-kotlin-training-project-lunch-tray#0">project</a>
                in the third module of the <a href="https://developer.android.com/courses/android-basics-kotlin/course">Android
                Basics in Kotlin</a>
                course:
            </p>
            <ol>
                <li>
                    Android applications have their programmatic entry point located in a <code>MainActivity</code>
                    class (this can be modified in the <code>AndroidManifest.xml</code> file, but changing this doesn't
                    appear to be a common practice). Within <code>MainActivity</code> we can initialize a
                    <code>NavHostFragment</code> which is a fragment that will be used to display the views contained
                    within our app. This fragment is owned by the <code>NavHost</code>, which contains the conext
                    for naviagting using a <code>NavController</code>. We also initialize this
                    <code>NavController</code>
                    within <code>MainActivity</code>. These steps are demonstrated in the code below:
                    <pre>
                        <code>
class MainActivity : AppCompatActivity() {

    private lateinit var navController: NavController

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_main)

        val navHostFragment = supportFragmentManager
            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment

        navController = navHostFragment.navController

        setupActionBarWithNavController(navController)
    }
}
                        </code>
                    </pre>
                </li>
                <li>
                    Next, a <code>navGraph.xml</code> is necessary in order to define the fragments known to the
                    <code>NavHost</code> and define both the directionality between fragments and their
                    corresponding layout files:
                    <pre>
                        <code>
                        <textarea cols="85" rows="10">
<fragment
        android:id="@+id/startOrderFragment"
        android:name="com.example.lunchtray.ui.order.StartOrderFragment"
        android:label="fragment_start_order"
        tools:layout="@layout/fragment_start_order" >
        <action
            android:id="@+id/action_startOrderFragment_to_entreeMenuFragment"
            app:destination="@id/entreeMenuFragment" />
    </fragment>
    <fragment
        android:id="@+id/entreeMenuFragment"
        android:name="com.example.lunchtray.ui.order.EntreeMenuFragment"
        android:label="fragment_entree_menu"
        tools:layout="@layout/fragment_entree_menu" >
        <action
            android:id="@+id/action_entreeMenuFragment_to_sideMenuFragment"
            app:destination="@id/sideMenuFragment" />
        <action
            android:id="@+id/action_entreeMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/sideMenuFragment"
        android:name="com.example.lunchtray.ui.order.SideMenuFragment"
        android:label="fragment_side_menu"
        tools:layout="@layout/fragment_side_menu" >
        <action
            android:id="@+id/action_sideMenuFragment_to_accompanimentMenuFragment"
            app:destination="@id/accompanimentMenuFragment" />
        <action
            android:id="@+id/action_sideMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/accompanimentMenuFragment"
        android:name="com.example.lunchtray.ui.order.AccompanimentMenuFragment"
        android:label="fragment_accompaniment_menu"
        tools:layout="@layout/fragment_accompaniment_menu" >
        <action
            android:id="@+id/action_accompanimentMenuFragment_to_checkoutFragment"
            app:destination="@id/checkoutFragment" />
        <action
            android:id="@+id/action_accompanimentMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/checkoutFragment"
        android:name="com.example.lunchtray.ui.order.CheckoutFragment"
        android:label="fragment_checkout"
        tools:layout="@layout/fragment_checkout" >
        <action
            android:id="@+id/action_checkoutFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
                        </textarea>
                        </code>
                    </pre>
                </li>
                <li>
                    Now click listeners must be incorporated into each fragment that will trigger the appropriate
                    transition from one view to another:
                    <pre>
                        <Code>
class StartOrderFragment : Fragment() {
    private var _binding: FragmentStartOrderBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        _binding = FragmentStartOrderBinding.inflate(inflater, container, false)
        val root: View = binding.root
        // Navigate to entree menu
        binding.startOrderBtn.setOnClickListener { // Setting the click listener to call navigation action
            findNavController().navigate(R.id.action_startOrderFragment_to_entreeMenuFragment)
        }
        return root
    }
}
                        </Code>
                    </pre>
                </li>
            </ol>
            <p>
                These steps demonstrate the implementation of code directly related to the Navigation Component, but it
                is
                worth noting that additional steps are necessary such as placing a <code>FragmentContainerView</code>
                inside the <code>MainActivity</code> layout file as well as defining the layout files for each
                individual fragment. (This app also makes use of a <code>ViewModel</code>, but this will be discussed
                in another section). Once all this has been finished, we can navigate through the application as
                demonstrated below:
            </p>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-4 ">
            <img src="images/LunchTray/start_order.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/entree.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/side.png" width="400">
        </div>
    </div>
    <div class="row">

        <div class="col-md-4 ">
            <img src="images/LunchTray/accomp.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/checkout.png" width="400">
        </div>
        <div class="col-md-4 text-center my-auto">
            <p>
                Clcicking the back arrow located in the AppBar at the top of the screen will result in a navigation
                action that displays the previosuly shown fragment.
            </p>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-6 text-center">
            <h3>
                <a href="https://github.com/harr1424/ListMaker">ListMaker</a>
            </h3>
            <p>
                ListMaker is a native Android app useful for creating nested lists of items worth remembering. This app
                implements the Android Jetpack
                <a href="https://developer.android.com/training/data-storage/room">Room Library</a>
                in order to persistently store user created lists within a SQL
                database on the user's device. This app also demonstrates the use of a ViewModel, LiveData, and the
                Android
                <a href="https://developer.android.com/guide/navigation/navigation-getting-started">Navigation
                    Component</a>.
            </p>
            <img alt="Koradi App screenshot" class="mx-auto d-block" height="700" src="images/ListMaker/groceries.png"/>
            <br>
            <a href='https://play.google.com/store/apps/details?id=com.harr1424.listmaker&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img
                    alt='Get it on Google Play'
                    height="100"
                    src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'/></a>
            <a href="https://f-droid.org/packages/com.harr1424.listmaker/">
                <img alt="Get it on F-Droid"
                     height="100"
                     src="https://fdroid.gitlab.io/artwork/badge/get-it-on.png">
            </a>
        </div>
        <div class="col-md-6 text-center">
            <h3>
                <a href="https://github.com/harr1424/koradi_radio-master">Koradi App</a>
            </h3>
            <p>
                The Koradi App is A Flutter project allowing users to interact with Koradi Radio. This application
                has been localized for six different languages and allows users to connect to a continuous audio stream
                originating from the Koradi Radio server as well as access recordings of past activities and submit
                listener questions via their web form. It implements a
                <a href="https://pub.dev/packages/audio_service">background audio service</a>
                in order to continuously play media.
            </p>
            <img alt="Koradi App screenshot" class="mx-auto d-block" height="700" src="images/ListMaker/koradi.png"/>
            <br>
            <a href='https://play.google.com/store/apps/details?id=com.koradi.radio&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'
               style="display: inline; overflow: hidden; border-radius: 23px; width: 250px; height: 100px;"><img
                    alt='Get it on Google Play'
                    height="100"
                    src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'/></a>
            <a href="https://apps.apple.com/us/app/koradi-app/id1606623606?itsct=apps_box_badge&amp;itscg=30200"
               style="display: inline; overflow: hidden; border-radius: 13px; width: 250px; height: 100px;"><img
                    alt="Download on the App Store"
                    src="https://tools.applemediaservices.com/api/badges/download-on-the-app-store/black/en-us?size=250x83&amp;releaseDate=1645142400&h=652fffa4f11b0f00c251d54e870e69a3"
                    style="width: 250px; height: 70px;"></a>
        </div>
    </div>
    <div class="pt-5"></div>
    <footer class="page-footer font-small blue">
        <div class="footer-copyright text-center py-3">
            Google Play and the Google Play logo are trademarks of Google LLC.
        </div>
    </footer>
</div>


<!-- Option 1: Bootstrap Bundle with Popper -->
<script crossorigin="anonymous"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>