<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">

    <!-- Bootstrap CSS -->
    <link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" rel="stylesheet">

    <link href="style.css" rel="stylesheet"/>

    <title>Mobile Application Development</title>
</head>
<body>
<div class="container">
    <div class="row ">
        <h1><a href="index.html">jharrington.dev</a></h1>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>Mobile Application Development</h3>
            <p>Eager to learn more about software development, and disappointed by the course offerings at UMT,
                I was fortunate to work with Patricia Duce in order to complete an Android Developer
                <a href="https://developer.android.com/courses/android-basics-kotlin/course">training course</a>
                and use the material contained therein to develop a course taught for the first time at UMT in Fall,
                2022.
            </p>
            <br>
            <h3>What I've Learned: Application Fundamentals</h3>
            <p>
                Android development has been an excellent way to get hands on practice writing clean code and
                work with software architecture patterns commonly found in industry applications,
                especially <i>model-view-viewmodel (
                <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVMM</a></i>) which is
                <a href="https://developer.android.com/jetpack/guide">endorsed</a> as a best practice
                when building Android apps.
            </p>
            <p> According to Android:</p>
            <blockquote CITE="https://developer.android.com/jetpack/guide"><I>
                Another important principle is that you should drive your UI from data models, preferably persistent
                models.
                Data models represent the data of an app. They're independent of the UI elements and other components
                in your app. This means that they are not tied to the UI and app component lifecycle, but will still be
                destroyed when the OS decides to remove the app's process from memory.
            </I></blockquote>
            <p>
                This effectively separates the application into two layers: a user-interface (UI) layer, and
                a data layer. This concept is just one example of various design principles that I learned while
                exploring application development.
            </p>
            <p>
                While Android applications have historically been written in Java, in May 2019 Google announced
                that the officially supported language for Android development would be
                <a href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)">Kotlin</a>.
                Kotlin has much in common with Java but its syntax has been changed to support type inference and
                eliminate the terminating semicolons, among many other features such as inline lambda functions,
                null safety, range expressions, and coroutines, all of which were explored in depth in the
                <a href="https://developer.android.com/courses/android-basics-kotlin/course">training course</a>.
            </p>
            <p>
                This course also emphasised the importance of testing application code, and each module contained an
                activity related to writing effective unit and functional tests.
                After teaching foundational concepts such as user interface (UI) management using layout resource files,
                click listeners, etc. the course demonstrated how to implement a
                <a href="https://developer.android.com/guide/topics/ui/layout/recyclerview">Recycler View</a>.
                Recycler Views are the component inside of Android applications that allow for an infinitely scrollable
                list.
                Think of any 'feed' you have encountered such as news feed on LinkedIn or Twitter, and you have the
                idea..
                Recycler Views have been designed to provide a user-friendly
                experience by scrolling smoothly and not freezing or jerking as fresh list items are loaded into the
                list.
            </p>
            <p>
                THe following is a code snippet from my application <i>ListMaker</i> which demonstrates the use of a
                Recycler View. Its individual components will be explained below:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
class MainAdapter(
    private val onItemClick: (MainItem) -> Unit, private val onItemLongClick: (MainItem) -> Boolean
) : ListAdapter<MainItem, MainAdapter.ViewHolder>(DiffCallback) {

    companion object DiffCallback : DiffUtil.ItemCallback<MainItem>() {
        override fun areItemsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem.itemName == newItem.itemName
        }

        override fun areContentsTheSame(oldItem: MainItem, newItem: MainItem): Boolean {
            return oldItem == newItem
        }

    }

    class ViewHolder(private var binding: ListItemBinding) : RecyclerView.ViewHolder(binding.root) {
        fun bind(item: MainItem) {
            binding.listItemText.text = item.itemName.toString()
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val viewHolder = ViewHolder(
            ListItemBinding.inflate(
                LayoutInflater.from(parent.context),
                parent,
                false
            )
        )
        viewHolder.itemView.setOnClickListener {
            val position = viewHolder.adapterPosition
            onItemClick(getItem(position))
        }
        viewHolder.itemView.setOnLongClickListener {
            val position = viewHolder.adapterPosition
            onItemLongClick(getItem(position))
        }
        return viewHolder
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(getItem(position))
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <div class="pt-3"></div>
            <ul>
                <li>
                    The <i>MainAdapter</i> class constructor expects as arguments two click listeners that determine
                    what occurs if a list item is clicked or long-clicked respectively and extends the
                    <i>ListAdapter</i>
                    class which expects a <i>DifCallback</i> object as an argument.
                </li>
                <li>
                    <i>ListAdapter</i> is a base class used for presenting list data in a Recycler View.
                </li>
                <li>
                    <i>DiffCallback</i> is a class that contains methods for computing the difference between two lists
                    and is useful to detect when only one or a few list elements have changed, and update only those
                    elements as opposed to the entire list. Here <i>DiffCallback</i> is implemented as a
                    <a href="https://kotlinlang.org/docs/object-declarations.html#companion-objects">companion
                        object</a>.
                </li>
                <li>
                    A companion object is an example of the <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton
                    design pattern</a>
                    and also resemble static objects in Java in the sense that they belong to a specific class but not
                    a given instance of that class.
                </li>
                <li>
                    The <code>ViewHolder</code> class accepts a <code>ListItemBinding</code> object as an argument. A
                    <code>ListItem</code> has been defined
                    in a separate xml file and in this case contains only instructions on how to display a text field.
                    The <code>ViewHolder</code> class is responsible for using this binding object to set
                    the text field of a given
                    list item to the appropriate item's name in the <code>bind</code> function.
                </li>
                <li>
                    The <code>onCreateViewHolder</code> function returns a <code>ViewHolder</code> and is responsible
                    for
                    <a href="https://developer.android.com/reference/android/view/LayoutInflater">inflating</a> the
                    <code>ListItem</code> view.
                </li>
                <li>
                    Additionally two click listeners are set within <code>onCreateViewHolder</code>. Additionally
                    listeners can be set here as well that handle the application's response to specific gestures
                    or other events.
                </li>
                <li>
                    Lastly, the <code>onBindViewHolder</code> function is responsible for performing the work defined
                    in <code>onCreateViewHolder</code> and therefore also any work defined in the <code>bind</code>
                    function in the <code>ViewHolder</code> constructor. In this case this entails setting a
                    <code>ListItem</code>'s text field to the appropriate item's name and setting two click listeners.
                </li>
            </ul>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: Application Navigation</h3>
            <p>
                Android provides a
                <a href="https://developer.android.com/guide/navigation/navigation-getting-started">Navigation
                    Component</a>
                which is intended to simply the process of navigating between views within an application. In Android,
                any screen displayed to a user is a view that has been defined in a <code>layout.xml</code> file. These
                views can
                be either activities or fragments. Simple applications can usually be contained within a single activity
                and make use of fragments to display different views. Utilizing the Navigation Component in such a
                situation is described below. The code for these examples has been taken from my solution to a
                <a href="https://developer.android.com/codelabs/basic-android-kotlin-training-project-lunch-tray#0">project</a>
                in the third module of the <a href="https://developer.android.com/courses/android-basics-kotlin/course">Android
                Basics in Kotlin</a>
                course:
            </p>
            <ol>
                <li>
                    Android applications have their programmatic entry point located in a <code>MainActivity</code>
                    class (this can be modified in the <code>AndroidManifest.xml</code> file, but changing this doesn't
                    appear to be a common practice). Within <code>MainActivity</code> we can initialize a
                    <code>NavHostFragment</code> which is a fragment that will be used to display the views contained
                    within our app. This fragment is owned by the <code>NavHost</code>, which contains the conext
                    for naviagting using a <code>NavController</code>. We also initialize this
                    <code>NavController</code>
                    within <code>MainActivity</code>. These steps are demonstrated in the code below:
                    <pre>
                        <code>
class MainActivity : AppCompatActivity() {

    private lateinit var navController: NavController

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_main)

        val navHostFragment = supportFragmentManager
            .findFragmentById(R.id.nav_host_fragment) as NavHostFragment

        navController = navHostFragment.navController

        setupActionBarWithNavController(navController)
    }
}
                        </code>
                    </pre>
                </li>
                <li>
                    Next, a <code>navGraph.xml</code> is necessary in order to define the fragments known to the
                    <code>NavHost</code> and define both the directionality between fragments and their
                    corresponding layout files:
                    <pre>
                        <code>
                        <textarea cols="85" rows="10">
<fragment
        android:id="@+id/startOrderFragment"
        android:name="com.example.lunchtray.ui.order.StartOrderFragment"
        android:label="fragment_start_order"
        tools:layout="@layout/fragment_start_order" >
        <action
            android:id="@+id/action_startOrderFragment_to_entreeMenuFragment"
            app:destination="@id/entreeMenuFragment" />
    </fragment>
    <fragment
        android:id="@+id/entreeMenuFragment"
        android:name="com.example.lunchtray.ui.order.EntreeMenuFragment"
        android:label="fragment_entree_menu"
        tools:layout="@layout/fragment_entree_menu" >
        <action
            android:id="@+id/action_entreeMenuFragment_to_sideMenuFragment"
            app:destination="@id/sideMenuFragment" />
        <action
            android:id="@+id/action_entreeMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/sideMenuFragment"
        android:name="com.example.lunchtray.ui.order.SideMenuFragment"
        android:label="fragment_side_menu"
        tools:layout="@layout/fragment_side_menu" >
        <action
            android:id="@+id/action_sideMenuFragment_to_accompanimentMenuFragment"
            app:destination="@id/accompanimentMenuFragment" />
        <action
            android:id="@+id/action_sideMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/accompanimentMenuFragment"
        android:name="com.example.lunchtray.ui.order.AccompanimentMenuFragment"
        android:label="fragment_accompaniment_menu"
        tools:layout="@layout/fragment_accompaniment_menu" >
        <action
            android:id="@+id/action_accompanimentMenuFragment_to_checkoutFragment"
            app:destination="@id/checkoutFragment" />
        <action
            android:id="@+id/action_accompanimentMenuFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
    <fragment
        android:id="@+id/checkoutFragment"
        android:name="com.example.lunchtray.ui.order.CheckoutFragment"
        android:label="fragment_checkout"
        tools:layout="@layout/fragment_checkout" >
        <action
            android:id="@+id/action_checkoutFragment_to_startOrderFragment"
            app:destination="@id/startOrderFragment" />
    </fragment>
                        </textarea>
                        </code>
                    </pre>
                </li>
                <li>
                    Now click listeners must be incorporated into each fragment that will trigger the appropriate
                    transition from one view to another:
                    <pre>
                        <Code>
class StartOrderFragment : Fragment() {
    private var _binding: FragmentStartOrderBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        _binding = FragmentStartOrderBinding.inflate(inflater, container, false)
        val root: View = binding.root
        // Navigate to entree menu
        binding.startOrderBtn.setOnClickListener { // Setting the click listener to call navigation action
            findNavController().navigate(R.id.action_startOrderFragment_to_entreeMenuFragment)
        }
        return root
    }
}
                        </Code>
                    </pre>
                </li>
            </ol>
            <p>
                These steps demonstrate the implementation of code directly related to the Navigation Component, but it
                is
                worth noting that additional steps are necessary such as placing a <code>FragmentContainerView</code>
                inside the <code>MainActivity</code> layout file as well as defining the layout files for each
                individual fragment. (This app also makes use of a <code>ViewModel</code>, but this will be discussed
                in another section). Once all this has been finished, we can navigate through the application as
                demonstrated below:
            </p>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-4 ">
            <img src="images/LunchTray/start_order.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/entree.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/side.png" width="400">
        </div>
    </div>
    <div class="row">

        <div class="col-md-4 ">
            <img src="images/LunchTray/accomp.png" width="400">
        </div>
        <div class="col-md-4 ">
            <img src="images/LunchTray/checkout.png" width="400">
        </div>
        <div class="col-md-4 text-center my-auto">
            <p>
                Clicking the back arrow located in the AppBar at the top of the screen will result in a navigation
                action that displays the previosuly shown fragment.
            </p>
        </div>
    </div>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: ViewModels and MVVM Architecture</h3>
            <p>
                In Android a
                <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a>
                is used to store application data in a way that respects the Android application
                <a href="https://developer.android.com/guide/components/activities/activity-lifecycle">lifecycle</a>.
                If data were to be stored local to a given activity or fragment, this data could be lost for any number
                of reasons out of the control of the application user or programmer such as rotating the device screen,
                the operating system re-allocating memory resources, and the activity or fragment loosing focus.
                Additionally, ViewModels simplify the process of sharing data between fragments. Separating application
                data from the user-interface is a common pattern in commercial codebases.
            </p>
            <p>
                To explore the implementation of a ViewModel I have copied code from my solution to the
                <a href="https://developer.android.com/codelabs/basic-android-kotlin-training-shared-viewmodel#0">Cupcake</a>
                codelab.
                Implementing a ViewModel within an application begins by simply declaring a new class that
                extends the ViewModel base class:
                <pre>
            <code>
class OrderViewModel : ViewModel() { }
            </code>
        </pre>
            <p>
                Next we define fields for our <code>OrderViewModel</code> class. There is a convention when doing this
                in Kotlin termed the <i>backing property</i> which holds that a mutable private variable is accessed
                by any functions within the <code>OrderViewModel</code> class and an immutable public variable is then provided for other classes
                to access. This is similar in theory to using getters and setters in Java. The example below uses
                <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a>
                types:
                <pre>
            <code>
     private val _quantity = MutableLiveData<Int>()
    val quantity: LiveData<Int> = _quantity

    private val _flavor = MutableLiveData<String>()
    val flavor: LiveData<String> = _flavor

    private val _date = MutableLiveData<String>()
    val date: LiveData<String> = _date

    private val _price = MutableLiveData<Double>()
    val price: LiveData<String> = Transformations.map(_price) {
        NumberFormat.getCurrencyInstance().format(it)
    }
            </code>
        </pre>
            <p>
                The following function definitions demonstrate how the private immutable variables are used within
                the <code>OrderViewModel</code> class:
                <pre>
            <code>
    fun setQuantity(numberCupcakes: Int) {
        _quantity.value = numberCupcakes
        updatePrice()
    }

    fun setFlavor(desiredFlavor: String) {
        _flavor.value = desiredFlavor
    }

    fun setDate(pickupDate: String) {
        _date.value = pickupDate
        updatePrice()
    }

    fun hasNoFalvorSet(): Boolean {
        return _flavor.value.isNullOrEmpty()
    }

    private fun updatePrice() {
        var calculatedPrice = (quantity.value ?: 0) * PRICE_PER_CUPCAKE
        if (dateOptions[0] == _date.value) {
            calculatedPrice += PRICE_FOR_SAME_DAY_PICKUP
        }
        _price.value = calculatedPrice
    }
            </code>
        </pre>
            <p>
                Now that our <code>OrderViewModel</code> is implemented, we can access its fields and methods from
                within our application. The following example demonstrates accessing <code>OrderViewModel</code>
                from the fragment <code>StartFragment</code>:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">

            <pre>
            <code>
class StartFragment : Fragment() {

    private val sharedViewModel: OrderViewModel by activityViewModels()

    ...

    // Begin a cupcake order by setting number of cupcakes and their flavor
    fun orderCupcake(quantity: Int) {
        sharedViewModel.setQuantity(quantity)
        if (sharedViewModel.hasNoFalvorSet()) {
            sharedViewModel.setFlavor(getString(R.string.vanilla))
        }
        findNavController().navigate(R.id.action_startFragment_to_flavorFragment)
    }
}
            </code>
        </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    <code>activityViewModels()</code> is called to return access to an <code>OrderViewModel</code>
                    instance shared between all fragments in the activity. The reference to this instance
                    is declared in a variable <code>sharedViewModel</code>
                </li>
                <li>
                    The methods defined in <code>OrderViewModel</code> can be accessed in order to update the value
                    of the fields such as quantity and flavor.
                </li>
            </ul>
            </div>
    </div>
    <p>
        Implementing a <code>ViewModel</code> is very straightforward and provides an easy way for fragments to
        access data that they have a common interest in. It also avoids numerous problems that can occur when code
        corresponding to the user interface stores application data.
    </p>
    <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-12 ">
            <h3>What I've Learned: Retrieving Data from the Internet</h3>
            <p>
                Most mobile applications perform network requests in order to retrieve and display information to
                their users such as emails, videos, and in the example for this section weather alerts. Android recommends
                reforming this work on a background thread since network requests can take a significant amount of time
                to complete. Performing network requests on the <i>main thread</i>, also known as the <i>UI thread</i> in
                Android because this is where UI information processed, is not recommended. It is best practice to perform these
                requests on a background thread in order to avoid the application appearing to freeze while the network request
                is handled. This situation is the basis of
                <a href="https://en.wikipedia.org/wiki/Asynchrony_(computer_programming)">asynchronus programming</a>.
                 Additionally, Android recommends segregating application code relating to netowrk requests within its
                own package, a practice which adheres to the
                <a href="https://en.wikipedia.org/wiki/Modular_programming">modular design</a> technique. In the example below,
                we will explore how this can be accomplished using two open source libraries designed for performing API
                requests and converting the returned JSON into a data class which can be passed in turn to a
                <code>ViewModel</code>.
            </p>
            <p>
                First, we implement our network layer as shown below:
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-md-6 ">
            <pre>
                <code>
private const val BASE_URL =
    "https://api.weather.gov/"

private val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory())
    .build()

private val retrofit = Retrofit.Builder()
    .addConverterFactory(MoshiConverterFactory.create(moshi))
    .baseUrl(BASE_URL)
    .build()

interface nwsAlerts {
    @GET("/alerts/active/zone/MTC063")
    suspend fun getALerts(): Alert
}

object Alerts {
    val retrofitService : nwsAlerts by lazy {
        retrofit.create(nwsAlerts::class.java)
    }
}
                </code>
            </pre>
        </div>
        <div class="col-md-6 ">
            <ul>
                <li>
                    First, we declare a reference to a <code>BASE_URL</code> which will simplify our API calls.
                </li>
                <li>
                    Next we create a
                    <a href="https://github.com/square/moshi">Moshi</a> object which will be used to deserialize the
                    JSON we receive from the API endpoint into Kotlin data classes (we must still declare these classes,
                    this will be demonstrated in the next section)
                </li>
                <li>
                    Next we must also define a
                    <a href="https://square.github.io/retrofit/">RetroFit</a> object responsible for converting the
                    API HTTP response into an interface
                </li>
                <li>
                    With our RetroFit object declared, we can now implement the interface which describes our API call.
                    In this case we perform an HTTP request to a particular endpoint that will return weather alerts for
                    Missoula County, Montana. The interface describes what the API call will do: return an Alert object,
                    and the next step maps this HTTP request to a function
                    <code>getAlerts()</code> that can be called from within our application code, specifically our
                    <code>ViewModel</code>.
                </li>
                <li>
                    Lastly, we create an <code>Alerts</code> object which holds an immutable variable (val in Kotlin)
                    <code>retrofitService</code> described by the interface above that will be lazily constructed
                    (here lazy means that this process will not occur until the <code>Alerts</code> object is first
                    accessed).
                </li>
            </ul>
        </div>
    </div>



        <div class="pt-5"></div>
    <div class="row">
        <div class="col-md-6 text-center">
            <h3>
                <a href="https://github.com/harr1424/ListMaker">ListMaker</a>
            </h3>
            <p>
                ListMaker is a native Android app useful for creating nested lists of items worth remembering. This app
                implements the Android Jetpack
                <a href="https://developer.android.com/training/data-storage/room">Room Library</a>
                in order to persistently store user created lists within a SQL
                database on the user's device. This app also demonstrates the use of a ViewModel, LiveData, and the
                Android
                <a href="https://developer.android.com/guide/navigation/navigation-getting-started">Navigation
                    Component</a>.
            </p>
            <img alt="Koradi App screenshot" class="mx-auto d-block" height="700" src="images/ListMaker/groceries.png"/>
            <br>
            <a href='https://play.google.com/store/apps/details?id=com.harr1424.listmaker&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'><img
                    alt='Get it on Google Play'
                    height="100"
                    src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'/></a>
            <a href="https://f-droid.org/packages/com.harr1424.listmaker/">
                <img alt="Get it on F-Droid"
                     height="100"
                     src="https://fdroid.gitlab.io/artwork/badge/get-it-on.png">
            </a>
        </div>
        <div class="col-md-6 text-center">
            <h3>
                <a href="https://github.com/harr1424/koradi_radio-master">Koradi App</a>
            </h3>
            <p>
                The Koradi App is A Flutter project allowing users to interact with Koradi Radio. This application
                has been localized for six different languages and allows users to connect to a continuous audio stream
                originating from the Koradi Radio server as well as access recordings of past activities and submit
                listener questions via their web form. It implements a
                <a href="https://pub.dev/packages/audio_service">background audio service</a>
                in order to continuously play media.
            </p>
            <img alt="Koradi App screenshot" class="mx-auto d-block" height="700" src="images/ListMaker/koradi.png"/>
            <br>
            <a href='https://play.google.com/store/apps/details?id=com.koradi.radio&pcampaignid=pcampaignidMKT-Other-global-all-co-prtnr-py-PartBadge-Mar2515-1'
               style="display: inline; overflow: hidden; border-radius: 23px; width: 250px; height: 100px;"><img
                    alt='Get it on Google Play'
                    height="100"
                    src='https://play.google.com/intl/en_us/badges/static/images/badges/en_badge_web_generic.png'/></a>
            <a href="https://apps.apple.com/us/app/koradi-app/id1606623606?itsct=apps_box_badge&amp;itscg=30200"
               style="display: inline; overflow: hidden; border-radius: 13px; width: 250px; height: 100px;"><img
                    alt="Download on the App Store"
                    src="https://tools.applemediaservices.com/api/badges/download-on-the-app-store/black/en-us?size=250x83&amp;releaseDate=1645142400&h=652fffa4f11b0f00c251d54e870e69a3"
                    style="width: 250px; height: 70px;"></a>
        </div>
    </div>
    <div class="pt-5"></div>
    <footer class="page-footer font-small blue">
        <div class="footer-copyright text-center py-3">
            Google Play and the Google Play logo are trademarks of Google LLC.
        </div>
    </footer>
</div>


<!-- Option 1: Bootstrap Bundle with Popper -->
<script crossorigin="anonymous"
        integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
        src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>